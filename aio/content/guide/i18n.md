# Internationalization (i18n)

<!--
Application internationalization is a many-faceted area of development, focused on making
applications available and user-friendly to a worldwide audience. This page describes Angular's
internationalization (i18n) tools, which can help you make your app available in multiple languages.

See the <live-example downloadOnly name="i18n">i18n Example</live-example> for a simple example of
an AOT-compiled app, translated into French.
-->
애플리케이션 국제화(internationalization, i18n)란 세계 여러 곳에 있는 사용자가 이해할 수 있는 언어로 애플리케이션을 제공하고, 좀 더 사용자에게 친숙하게 다가가려면 어떻게 해야 할지에 중점을 두는 개발 영역입니다.
이 문서는 Angular가 제공하는 i18n 툴에 대해 소개합니다. 이 툴을 활용하면 애플리케이션을 여러 언어로 제공할 수 있을 것입니다.

프랑스어로 제공되는 앱을 AOT 방식으로 컴파일한 <live-example downloadOnly name="i18n">i18n 예제</live-example>를 확인해 보세요.

{@a angular-i18n}
<!--
## Angular and i18n
-->
## Angular와 i18n

<!--
*Internationalization* is the process of designing and preparing your app to be usable in different languages. 
*Localization* is the process of translating your internationalized app into specific languages for particular locales. 

Angular simplifies the following aspects of internationalization:
* Displaying dates, number, percentages, and currencies in a local format.
* Preparing text in component templates for translation.
* Handling plural forms of words.
* Handling alternative text.

For localization, you can use the [Angular CLI](cli) to generate most of the boilerplate necessary to create files for translators, and to publish your app in multiple languages. 
After you have set up your app to use i18n, the CLI can help you with the following steps:
* Extracting localizable text into a file that you can send out to be translated.
* Building and serving the app for a given locale, using the translated text.
* Creating multiple language versions of your app.
-->
*Internationalization*은 애플리케이션을 여러 언어로 사용할 수 있도록 준비하는 애플리케이션 설계 단계 중 하나입니다.
그리고 *Localization*은 i18n이 적용된 앱을 특정 언어로 번역하는 단계를 의미합니다.

Angular는 i18n을 다음과 같이 단순화했습니다:
* 화면에 표시되는 날짜, 숫자, 퍼센트, 화폐는 해당 지역의 형식에 맞게 제공한다.
* 컴포넌트 템플릿에 표시되는 문구는 해당 언어로 제공한다.
* 폼에 사용하는 단어는 여러가지를 준비한다.
* 필요하다면 대체 텍스트를 준비한다.

Localization의 관점에서는 [Angular CLI](cli)를 사용해서 번역에 필요한 파일을 생성하거나 앱을 여러 언어로 빌드해서 배포할 수 있습니다.
이 작업을 하려면 애플리케이션에 i18n 설정을 적용해야 CLI가 제공하는 다음 기능을 활용할 수 있습니다:
* 번역할 내용을 모아 텍스트 파일로 생성할 수 있습니다.
* 텍스트를 번역하고 나면 특정 언어를 선택해서 애플리케이션을 빌드하고 실행해볼 수 이 ㅆ습니다.
* 애플리케이션을 여러 언어로 빌드할 수 있습니다.

{@a setting-up-locale}
{@a setting-up-the-locale-of-your-app}
<!--
## Setting up the locale of your app
-->
## locale 환경설정

<!--
A locale is an identifier (id) that refers to a set of user preferences that tend to be shared
within a region of the world, such as country. This document refers to a locale identifier as a
"locale" or "locale id".

A Unicode locale identifier is composed of a Unicode language identifier and (optionally) the
character `-` followed by a locale extension. (For historical reasons the character `_` is supported
as an alternative to `-`.)  For example, in the locale id `fr-CA` the `fr` refers to the French
language identifier, and the `CA` refers to the locale extension Canada.
-->
locale은 국가와 같이 한 지역에 사는 사람들이 공유하는 것들을 가리키는 단어입니다. 서로 구분할 수 있기 때문에 id의 한 종류라고도 할 수 있습니다.
이 문서에서 locale은 "locale"이나 "locale id"로 사용합니다.

유니코드 locale id는 유니코드 언어 id를 사용하며, 이 뒤에  `-`를 붙이고 locale 확장 id를 붙일 수도 있습니다.
(`-` 대신 `_` 가 사용되는 경우도 있습니다.)
예를 들어 `fr-CA`라는 locale id가 있다면, 이것은 기본적으로 프랑스어 id를 의미하며, `CA`가 붙었기 때문에 캐나다에서 사용하는 프랑스어를 의미합니다.

<div class="alert is-critical">

<!--
Angular follows the Unicode LDML convention that uses stable identifiers (Unicode locale identifiers)
based on the norm [BCP47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt). It is very important that
you follow this convention when you define your locale, because the Angular i18n tools use this
locale id to find the correct corresponding locale data.
-->
Angular는 [BCP47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt)로 정의된 Unicode LDML 컨벤션을 준수합니다.
Angular에서 locale id를 지정할 때도 Angular CLI i18n툴은 이 문서에서 정의하는 locale id를 기준으로 다국어 데이터를 제공합니다.

</div>

<!--
By default, Angular uses the locale `en-US`, which is English as spoken in the United States of America.

To set your app's locale to another value, use the CLI parameter `--configuration` with the value of the locale id that you want to use:
-->
기본적으로 Angular가 사용하는 locale은 `en-US`이기 때문에, 미국에서 사용되는 영어를 기준으로 합니다.

애플리케이션 locale을 변경하려면 Angular CLI 명령을 실행할 때 `--configuration` 옵션으로 원하는 locale id를 지정하면 됩니다:

<code-example language="sh" class="code-shell">
  ng serve --configuration=fr
</code-example>

<!--
If you use JIT, you also need to define the `LOCALE_ID` provider in your main module:
-->
JIT 컴파일러를 사용한다면 메인 모듈에 `LOCALE_ID` 프로바이더를 사용할 수도 있습니다:

<code-example path="i18n/doc-files/app.module.ts" header="src/app/app.module.ts" linenums="false">
</code-example>

<!--
For more information about Unicode locale identifiers, see the
[CLDR core spec](http://cldr.unicode.org/core-spec#Unicode_Language_and_Locale_Identifiers).

For a complete list of locales supported by Angular, see
[the Angular repository](https://github.com/angular/angular/tree/master/packages/common/locales).

The locale identifiers used by CLDR and Angular are based on [BCP47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt).
These specifications change over time; the following table maps previous identifiers to current ones at
time of writing:
-->
유니코드 locald id에 대해 자세하게 알아보려면 [CLDR core spec](http://cldr.unicode.org/core-spec#Unicode_Language_and_Locale_Identifiers) 문서를 참고하세요.

Angular가 제공하는 전체 locale 목록은 [Angular 레파지토리](https://github.com/angular/angular/tree/master/packages/common/locales)에서 확인할 수 있습니다.

CLDR과 Angular가 사용하는 locale id는 모두 [BCP47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt)를 기준으로 합니다.
이 스펙은 변경될 수 있기 때문에 이전과 달라진 항목도 일부 있습니다.

<!--
| Locale name                   | Old locale id     | New locale id |
|-------------------------------|-------------------|---------------|
| Indonesian                    | in                | id            |
| Hebrew                        | iw                | he            |
| Romanian Moldova              | mo                | ro-MD         |
| Norwegian Bokmål              | no, no-NO         | nb            |
| Serbian Latin                 | sh                | sr-Latn       |
| Filipino                      | tl                | fil           |
| Portuguese Brazil             | pt-BR             | pt            |
| Chinese Simplified            | zh-cn, zh-Hans-CN | zh-Hans       |
| Chinese Traditional           | zh-tw, zh-Hant-TW | zh-Hant       |
| Chinese Traditional Hong Kong | zh-hk             | zh-Hant-HK    |
-->
| Locale 이름                   | 이전 locale id     | 새 locale id |
|-------------------------------|-------------------|---------------|
| Indonesian                    | in                | id            |
| Hebrew                        | iw                | he            |
| Romanian Moldova              | mo                | ro-MD         |
| Norwegian Bokmål              | no, no-NO         | nb            |
| Serbian Latin                 | sh                | sr-Latn       |
| Filipino                      | tl                | fil           |
| Portuguese Brazil             | pt-BR             | pt            |
| Chinese Simplified            | zh-cn, zh-Hans-CN | zh-Hans       |
| Chinese Traditional           | zh-tw, zh-Hant-TW | zh-Hant       |
| Chinese Traditional Hong Kong | zh-hk             | zh-Hant-HK    |

{@a i18n-pipes}

<!--
## i18n pipes
-->
## i18n 파이프

<!--
Angular pipes can help you with internationalization: the `DatePipe`, `CurrencyPipe`, `DecimalPipe`
and `PercentPipe` use locale data to format data based on the `LOCALE_ID`.

By default, Angular only contains locale data for `en-US`. If you set the value of
`LOCALE_ID` to another locale, you must import locale data for that new locale.
The CLI imports the locale data for you when you use the parameter `--configuration` with `ng serve` and
`ng build`.

If you want to import locale data for other languages, you can do it manually:
-->
Angular가 제공하는 파이프 중 `DatePipe`, `CurrencyPipe`, `DecimalPipe`, `PercentPipe`는 애플리케이션에 설정한 `LOCALE_ID`에 맞게 자동으로 다국어를 지원합니다.

기본적으로 Angular가 로드하는 locale 데이터는 `en-US` 뿐입니다.
그래서 `LOCALE_ID`를 다른 값으로 지정했다면 이 locale에 맞는 locale 데이터를 로드해야 합니다.
이 때 Angular CLI 명령을 실행하면서 `--configuration` 옵션을 지정했다면, `ng serve` 명령이나 `ng build` 명령을 실행할 때 자동으로 locale 데이터를 로드합니다.

그리고 이 데이터를 수동으로 로드하려면 다음과 같이 작성하면 됩니다:

<code-example path="i18n/doc-files/app.locale_data.ts" region="import-locale" header="src/app/app.module.ts" linenums="false">
</code-example>

<!--
The first parameter is an object containing the locale data imported from `@angular/common/locales`.
By default, the imported locale data is registered with the locale id that is defined in the Angular
locale data itself.
If you want to register the imported locale data with another locale id, use the second parameter to
specify a custom locale id. For example, Angular's locale data defines the locale id for French as
"fr". You can use the second parameter to associate the imported French locale data with the custom
locale id "fr-FR" instead of "fr".

The files in `@angular/common/locales` contain most of the locale data that you
need, but some advanced formatting options might only be available in the extra dataset that you can
import from `@angular/common/locales/extra`. An error message informs you when this is the case.
-->
첫번째 인자는 `@angular/common/locales`에서 로드한 locale 데이터 객체입니다.
기본적으로 locale 데이터를 로드하면 이 데이터가 등록된 locale id를 기준으로 Angular에 등록됩니다.
그런데 데이터에 지정된 locale id 말고 다른 locale id를 사용하고 싶다면 원하는 locale id를 두번째 인자로 전달하면 됩니다.
기본적으로 Angular에서 프랑스어 locale 데이터가 제공되는 파일은 "fr"입니다.
그런데 이 데이터를 등록하면서 "fr" 대신 "fr-FR"이라는 locale id로 등록할 수 있습니다.

`@angular/common/locales` 패키지에는 대부분의 경우에 사용할 수 있는 locale 데이터가 포함되어 있지만, 이 패키지에서 제공하는 것 외에 다른 데이터셋이 더 필요하다면 `@angular/common/locales/extra` 패키지를 로드해서 사용해도 됩니다.
이 패키지의 내용이 필요한 경우는 에러 메시지로 출력됩니다.

  <code-example path="i18n/doc-files/app.locale_data_extra.ts" region="import-locale-extra" header="src/app/app.module.ts" linenums="false">
  </code-example>

<div class="alert is-helpful">

  <!--
  All locale data used by Angular are extracted from the Unicode Consortium's
  <a href="http://cldr.unicode.org/" title="CLDR">Common Locale Data Repository (CLDR)</a>.
  -->
  Angular가 제공하는 locale 데이터는 모두 Unicode Consortium이 제공하는 <a href="http://cldr.unicode.org/" title="CLDR">Common Locale Data Repository (CLDR)</a>를 참고했습니다.

</div>

<!--
## Template translations
-->
## 템플릿 번역

<div class="alert is-helpful">

  <!--
  This document refers to a unit of translatable text as "text," a "message", or a
  "text message."
  -->
  이 문서에서 사용하는 "텍스트", "메시지", "텍스트 메시지"는 번역 대상이 되는 문자열 단위를 의미합니다.

</div>

<!--
The i18n template translation process has four phases:

1. Mark static text messages in your component templates for translation.

2. Create a translation file: Use the Angular CLI `xi18n` command to extract the marked text into an industry-standard translation source file.

3. Edit the generated translation file: Translate the extracted text into the target language.

4. Merge the completed translation file into the app. To do this, use the Angular CLI `build` command to compile the app, choosing a [locale-specific configuration](#merge-aot), or specifying the following command options.

    * `--i18nFile`=*path to the translation file*
    * `--i18nFormat`=*format of the translation file*
    * `--i18nLocale`= *locale id* 

The command replaces the original messages with translated text, and generates a new version of the app in the target language. 

You need to build and deploy a separate version of the app for each supported language.
-->
i18n 템플릿 번역은 4단계로 진행합니다:

1. 컴포넌트 템플릿에서 번역할 정적 텍스트 메시지를 표시합니다.

2. 다국어 파일을 생성합니다: Angular CLI `xi18n` 명령을 실행하면 번역할 텍스트로 표시한 문구를 모아 파일로 추출할 수 있습니다.

3. 다국어 파일을 수정합니다: 추출된 문구를 원하는 언어로 변환합니다.

4. 번역한 파일을 애플리케이션에 적용합니다. Angular CLI `build` 명령을 실행하면 애플리케이션이 빌드되는데, 이 때 [locale 설정](#merge-aot)을 적용하거나 다음 옵션 중 하나를 사용하면 됩니다.

    * `--i18nFile`=*번역 파일의 위치*
    * `--i18nFormat`=*번역 파일의 형식*
    * `--i18nLocale`= *locale id* 

이 명령을 실행하면 원래 메시지 대신 번역 파일의 텍스트가 적용되며, 애플리케이션도 해당 언어로 빌드됩니다.

애플리케이션을 여러 언어로 제공하려면 각각의 언어로 애플리케이션을 빌드하고 배포해야 합니다.

{@a i18n-attribute}
<!--
### Mark text with the i18n attribute
-->
### i18n 어트리뷰트로 번역대상 지정하기

<!--
The Angular `i18n` attribute marks translatable content. Place it on every element tag whose fixed
text is to be translated.

In the example below, an `<h1>` tag displays a simple English language greeting, "Hello i18n!"
-->
Angular가 제공하는 `i18n` 어트리뷰트를 사용하면 번역할 문구를 지정할 수 있습니다.
번역하려는 문구가 포함된 모든 엘리먼트 태그에 이 어트리뷰트를 지정하세요.

아래 예제에서 `<h1>` 태그에는 "Hello i18n!"이라는 영어 문장이 표시됩니다.

<code-example path="i18n/doc-files/app.component.html" region="greeting" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
To mark the greeting for translation, add the `i18n` attribute to the `<h1>` tag.
-->
이 문장을 번역 대상으로 지정하려면 `<h1>` 태그에 `i18n` 어트리뷰트를 추가하면 됩니다.

<code-example path="i18n/doc-files/app.component.html" region="i18n-attribute" header="src/app/app.component.html" linenums="false">
</code-example>


<div class="alert is-helpful">

  <!--
  `i18n` is a custom attribute, recognized by Angular tools and compilers.
  After translation, the compiler removes it. It is not an Angular directive.
  -->
  `i18n`은 Angular 툴과 컴파일러가 번역 대상을 인식하기 위해 제공되는 커스텀 어트리뷰트이며, Angular 디렉티브는 아닙니다.
  번역 작업이 끝나면 컴파일러가 이 어트리뷰트를 제거합니다.

</div>


{@a help-translator}
<!--
### Help the translator with a description and meaning
-->
### 문장의 의미 추가하기

<!--
To translate a text message accurately, the translator may need additional information or context.

You can add a description of the text message as the value of the `i18n` attribute, as shown in the
example below:
-->
텍스트 메시지를 정확하게 번역하려면 해당 문구가 어떤 맥락에서 사용되었는지에 대한 정보가 더 필요할 수도 있습니다.

그렇다면 이 정보는 `i18n` 어트리뷰트에 다음과 같이 추가할 수 있습니다:

<code-example path="i18n/doc-files/app.component.html" region="i18n-attribute-desc" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
The translator may also need to know the meaning or intent of the text message within this particular
app context.

You add context by beginning the `i18n` attribute value with the _meaning_ and
separating it from the _description_ with the `|` character: `<meaning>|<description>`
-->
이 정보가 제공되면 번역자가 해당 텍스트 메시지가 애플리케이션의 어떤 맥락에 사용되었는지 제대로 알 수 있습니다.

그리고 `i18n`에 해당 문구의 _의미(meaning)_ 와 _설명(description)_ 을 함께 제공하려면 `|` 문자를 사용해서 `<의미>|<설명>` 형식으로 작성하면 됩니다:

<code-example path="i18n/doc-files/app.component.html" region="i18n-attribute-meaning" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
All occurrences of a text message that have the same meaning will have the same translation.
A text message that is associated with different meanings can have different translations.

The Angular extraction tool preserves both the meaning and the description in the translation
source file to facilitate contextually-specific translations, but only the combination of meaning
and text message are used to generate the specific id of a translation. If you have two
similar text messages with different meanings, they are extracted separately. If you have two similar
text messages with different descriptions (not different meanings), then they are extracted only once.
-->
같은 의미로 사용된 텍스트 메시지는 모두 동일하게 번역되어야 합니다.
그런데 텍스트는 같더라도 다른 맥락으로 사용된 텍스트 메시지는 다르게 번역될 수도 있습니다.

i18n 메시지를 추출하는 툴은 텍스트가 맥락에 어울리게 번역될 수 있도록 해당 문장의 의미와 설명을 모두 추출하지만, 설명이 제공되지 않은 메시지에 대해서는 id를 부여합니다.
그래서 비슷하지만 서로 다른 의미로 사용된 두 메시지가 있다면 이 메시지는 id로 구분할 수 있습니다.
하지만 두 메시지의 설명이 다르고 의미가 같다면, 이 메시지는 한번만 추출됩니다.


{@a custom-id}
<!--
### Set a custom id for persistence and maintenance
-->
### 유지관리를 위해 커스텀 id 지정하기

<!--
The angular i18n extractor tool generates a file with a translation unit entry for each `i18n`
attribute in a template. By default, it assigns each translation unit a unique id such as this one:
-->
Angular i18n 추출 툴로 파일을 생성하면 템플릿에 `i18n` 어트리뷰트가 적용된 각 문구를 유닛 단위(translation unit)로 생성합니다.
그리고 기본적으로 이 유닛에는 다음과 같이 유일한 id가 지정됩니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="generated-id" linenums="false">
</code-example>

<!--
When you change the translatable text, the extractor tool generates a new id for that translation unit.
You must then update the translation file with the new id.

Alternatively, you can specify a custom id in the `i18n` attribute by using the prefix `@@`.
The example below defines the custom id `introductionHeader`:
-->
번역할 문구를 변경하고 나면 i18n 추출 툴이 생성하는 id도 변경됩니다.
번역 파일의 내용도 새로운 id로 변경해야 합니다.

이 과정이 번거롭다면 `i18n` 어트리뷰트를 지정할 때 `@@` 접두사를 사용해서 커스텀 id를 지정할 수 있습니다.
그래서 `introductionHeader`라는 커스텀 id를 지정하려면 다음과 같이 작성하면 됩니다:

<code-example path='i18n/doc-files/app.component.html' region='i18n-attribute-solo-id' header='app/app.component.html' linenums="false">
</code-example>

<!--
When you specify a custom id, the extractor tool and compiler generate a translation unit with that
custom id.
-->
커스텀 id를 지정하고 나면 i18n 추출 툴이 번역 유닛을 생성할 때 이 커스텀 id를 사용하게 됩니다.

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="custom-id" linenums="false">
</code-example>

<!--
The custom id is persistent. The extractor tool does not change it when the translatable text changes.
Therefore, you do not need to update the translation. This approach makes maintenance easier.
-->
커스텀 id는 계속 유지됩니다.
번역할 문구가 변경되더라도 i18n 추출 툴이 할당하는 id는 변경되지 않습니다.
그래서 커스텀 id를 사용하면 문구를 변경하더라도 번역 결과 파일을 수정할 필요가 없습니다.
유지보수하기에는 이 방법이 더 편합니다.

<!--
#### Use a custom id with a description
-->
#### 설명과 커스텀 id 함께 사용하기

<!--
You can use a custom id in combination with a description by including both in the value of the
`i18n` attribute. In the example below, the `i18n` attribute value includes a description, followed
by the custom `id`:
-->
커스텀 id는 해당 문구에 대한 설명과 함께 `i18n` 어트리뷰트에 사용할 수 있습니다.
다음과 같이 작성하면 됩니다:

<code-example path='i18n/doc-files/app.component.html' region='i18n-attribute-id' header='app/app.component.html' linenums="false">
</code-example>

<!--
You also can add a meaning, as shown in this example:
-->
비슷한 방식으로, 문구의 의미를 함께 작성할 수도 있습니다:

<code-example path='i18n/doc-files/app.component.html' region='i18n-attribute-meaning-and-id' header='app/app.component.html' linenums="false">
</code-example>

<!--
#### Define unique custom ids
-->
#### 커스텀 id는 유일한 값으로 지정하세요.

<!--
Be sure to define custom ids that are unique. If you use the same id for two different text messages,
only the first one is extracted, and its translation is used in place of both original text messages.

In the example below the custom id `myId` is used for two different messages:
-->
커스텀 id는 반드시 유일한 값으로 지정해야 합니다.
서로 다른 텍스트 메시지에 같은 id가 지정되면, i18n 툴이 첫번째 메시지만 추출하며, 번역된 문구는 같은 id가 지정된 모든 곳에 적용됩니다.

아래 예제에서 `myId`는 서로 다른 메시지 2개에 지정되었습니다.

  ```html
    <h3 i18n="@@myId">Hello</h3>
    <!-- ... -->
    <p i18n="@@myId">Good bye</p>
  ```

<!--
Consider this translation to French:
-->
이 내용을 프랑스어로 번역했다고 합시다:

  ```xml
    <trans-unit id="myId" datatype="html">
      <source>Hello</source>
      <target state="new">Bonjour</target>
    </trans-unit>
  ```

<!--
Because the custom id is the same, both of the elements in the resulting translation contain
the same text, `Bonjour`:
-->
그러면 두 메시지의 커스텀 id가 같기 때문에 `<h3>`과 `<p>`에는 모두 `Bonjour`라는 텍스트가 들어갑니다:

  ```html
    <h3>Bonjour</h3>
    <!-- ... -->
    <p>Bonjour</p>
  ```



{@a no-element}
<!--
### Translate text without creating an element
-->
### 엘리먼트를 사용하지 않은 텍스트 번역하기

<!--
If there is a section of text that you would like to translate, you can wrap it in a `<span>` tag.
However, if you don't want to create a new DOM element merely to facilitate translation,
you can wrap the text in an `<ng-container>` element.
The `<ng-container>` is transformed into an html comment:
-->
번역하려는 텍스트 문구가 있다면 이 테스트는 `<span>` 태그로 감싼 후에 번역 대상으로 지정할 수 있습니다.
그런데 새로운 DOM 엘리먼트를 추가하지 않으면서 문구를 번역하려면, 이 텍스트를 `<ng-container>` 엘리먼트로 감싸면 됩니다.
`<ng-container>`는 HTML로 렌더링될 때 주석으로 처리됩니다:

<code-example path="i18n/src/app/app.component.html" region="i18n-ng-container" header="src/app/app.component.html" linenums="false">
</code-example>

{@a translate-attributes}
<!--
### Translate attributes
-->
### 어트리뷰트 번역하기

<!--
Displayed text is sometimes supplied as the value of an attribute, rather than the content of tag.
For example, if your template has an image with a `title` attribute, the text value of the `title` attribute needs to be translated.
-->
어떤 경우에는 태그 안에 있는 내용이 화면에 표시되지 않고 어트리뷰트로 지정된 값이 화면에 표시되는 경우가 있습니다.
예를 들어 템플릿에 이미지가 있고, 이 이미지에는 `title` 어트리뷰트가 지정되었는데, 이 `title` 어트리뷰트의 내용을 번역해야 한다고 합시다.

<code-example path="i18n/doc-files/app.component.html" region="i18n-title" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
To mark an attribute for translation, add an attribute in the form of `i18n-x`,
where `x` is the name of the attribute to translate. The following example shows how to mark the
`title` attribute for translation by adding the `i18n-title` attribute on the `img` tag:
-->
어트리뷰트를 번역 대상으로 지정하려면 번역하려는 어트리뷰트 이름(`x`)을 가리키는 `i18n-x` 어트리뷰트를 추가하면 됩니다.
그래서 아래 예제에서는 `img` 태그의 `title` 어트리뷰트를 번역대상으로 지정하기 위해 `i18n-title` 어트리뷰트를 추가했습니다.

<code-example path="i18n/src/app/app.component.html" region="i18n-title-translate" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
This technique works for any attribute of any element.

You also can assign a meaning, description, and id with the `i18n-x="<meaning>|<description>@@<id>"`
syntax.
-->
이 테크닉은 엘리먼트에 존재하는 모든 어트리뷰트에 적용할 수 있습니다.

그리고 이 방식을 활용하면서 문장의 의미와 설명을 추가해서 `i18n-x="<meaning>|<description>@@<id>"` 라는 문법을 사용할 수도 있습니다.

<!--
## Regular expressions for plurals and selections
-->
## 정규 표현식으로 복수형과 선택지 정의하기

<!--
Different languages have different pluralization rules and grammatical constructions that add 
complexity to the translation task. 
You can use regular expressions with the `plural` and `select` clauses to provide patterns that aid translation in these cases.
-->
세계 여러 언어에는 서로 다른 복수형 문법이 있고 서로 다른 방식으로 조합될 수 있기 때문에 번역 작업이 어렵기도 합니다.
이런 경우에는 `plural`과 `select` 조건을 정규 표현식으로 사용해서 여러가지로 사용될 수 있는 패턴을 정의할 수 있습니다.

{@a plural-ICU}
<!--
### Pluralization
-->
### 복수형 문법(Pluralization)

<!--
Suppose that you want to say that something was "updated x minutes ago".
In English, depending upon the number of minutes, you could display "just now", "one minute ago",
or "x minutes ago" (with x being the actual number).
Other languages might express the cardinality differently.

The example below shows how to use a `plural` ICU expression to display one of those three options
based on when the update occurred:
-->
어떤 것이 "x분 전에 업데이트 되었다"는 것을 표현하고 싶다고 합시다.
영어를 예로 들면 분 단위를 사용해서 "just now"라고 표현할 수도 있고 "one minute ago"라고 표현할 수도 있으며 "x minutes ago"라고 표현할 수도 있습니다.
다른 언어는 또 다른 방식으로 표현할 수도 있습니다.

아래 예제에서는 `plural` ICU 표현식을 사용해서 내용이 변경된 시점에 따라 이 내용을 3가지 방식으로 표현합니다:

<code-example path="i18n/src/app/app.component.html" region="i18n-plural" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
* The first parameter is the key. It is bound to the component property (`minutes`), which determines
the number of minutes.
* The second parameter identifies this as a `plural` translation type.
* The third parameter defines a pluralization pattern consisting of pluralization categories and their matching values.
-->
* 첫번째 인자는 키(key)입니다. 이 값은 업데이트된 시점을 표현하는 컴포넌트 프로퍼티 `minutes`와 바인딩됩니다.
* 두번째 인자는 `plural` 번역 타입을 의미하는 id입니다.
* 세번째 인자는 복수형 문법을 조합하는 패턴입니다. 이 패턴은 복수형 카테고리와 이 카테고리에 해당하는 값으로 조합됩니다.

<div class="alert is-helpful">

  <!--
  This syntax conforms to the
  <a href="http://userguide.icu-project.org/formatparse/messages" title="ICU Message Format">ICU Message Format</a>
  as specified in the
  <a href="http://cldr.unicode.org/index/cldr-spec/plural-rules" title="Pluralization Rules">CLDR pluralization rules</a>.
  -->
  이 문법은 <a href="http://cldr.unicode.org/index/cldr-spec/plural-rules" title="Pluralization Rules">CLDR pluralization rules</a>에 <a href="http://userguide.icu-project.org/formatparse/messages" title="ICU Message Format">ICU Message Format</a>으로 정의되어 있습니다.

</div>

<!--
Pluralization categories include (depending on the language):

* =0 (or any other number)
* zero
* one
* two
* few
* many
* other
-->
복수형 카테고리로 사용할 수 있는 항목은 다음과 같습니다 (언어에 따라 다릅니다):

* =0 (이나 정의되지 않은 경우)
* zero
* one
* two
* few
* many
* other

<!--
After the pluralization category, put the default English text in braces (`{}`).

In the example above, the three options are specified according to that pluralization pattern. For
talking about zero minutes, you use `=0 {just now}`. For one minute, you use `=1 {one minute}`.
Any unmatched cardinality uses `other {{{minutes}} minutes ago}`. You could choose to add patterns
for two, three, or any other number if the pluralization rules were different. For the example of
"minute", only these three patterns are necessary in English.
-->
복수형 카테고리 뒤에는 괄호로 기본 영어 문구를 지정합니다(`{}`).

위 예제를 다시 보면, 이 예제에는 복수형 패턴이 3개 선언되었습니다.
1분이 되지 않은 경우는 `=0 {just now}`로 지정했습니다.
그리고 1분인 경우는 `=1 {one minute}`로 지정했습니다.
둘 다 해당되지 않는 경우는 `other {{{minutes}} minutes ago}`를 지정했습니다.
물론 two, three 등 복수형 규칙은 얼마든지 추가할 수 있습니다.
이 예제에서 다루는 것처럼 영어로 "minute" 단위를 표현하는 것이라면 3가지 경우만 있으면 됩니다.

<div class="alert is-helpful">

  <!--
  You can use interpolations and html markup inside of your translations.
  -->
  번역할 문구 안에는 문자열 바인딩이나 HTML 마크업을 사용할 수도 있습니다.

</div>

{@a select-ICU}
<!--
### Select among alternative text messages
-->
### 대체 문구 중에서 선택하기

<!--
If your template needs to display different text messages depending on the value of a variable, you
need to translate all of those alternative text messages.

You can handle this with a `select` ICU expression. It is similar to the `plural` expressions
except that you choose among alternative translations based on a string value instead of a number,
and you define those string values.

The following format message in the component template binds to the component's `gender` property,
which outputs one of the following string values: "m", "f" or "o".
The message maps those values to the appropriate translations:
-->
템플릿에서 변수의 값에 따라 다른 문구를 표시해야 한다면, 이 문구를 모두 번역해놓고 하나를 선택하는 방법을 활용할 수도 있습니다.

이 경우에는 `select` ICU 표현식을 사용합니다.
이 문법은 `plural` 표현식과 비슷하지만, 숫자값을 기준으로 문구를 선택하는 것이 아니라 문자열(string) 값을 기준으로 문구를 선택합니다.

아래 예제는 컴포넌트의 `gender` 프로퍼티가 컴포넌트 템플릿에 바인딩되어 메시지를 표시하는데, 이 때 프로퍼티의 값은 "m", "f", "o" 중 하나입니다.
그러면 이 선택자를 사용해서 다음과 같은 표현식을 정의할 수 있습니다:

<code-example path="i18n/src/app/app.component.html" region="i18n-select" header="src/app/app.component.html" linenums="false">
</code-example>

{@a nesting-ICUS}
<!--
### Nesting plural and select ICU expressions
-->
### 중첩된 복수 표현식과 대체 문구 선택 표현식

<!--
You can also nest different ICU expressions together, as shown in this example:
-->
서로 다른 ICU 표현식은 아래 예제처럼 동시에 사용할 수도 있습니다:

<code-example path="i18n/src/app/app.component.html" region="i18n-nested" header="src/app/app.component.html">
</code-example>

{@a ng-xi18n}
{@a ng-xi18n-options}

<!--
## Create a translation source file
-->
## 번역 소스 파일 생성하기

<!--
When your app is ready, you can use the Angular CLI to extract the text messages marked with `i18n` and attributes marked with `i18n-x` into a translation source file.
Open a terminal window at the root of the app project and run the CLI command `xi18n`.
-->
번역할 텍스트를 모두 체크했으면 이제 Angular CLI를 사용해서 `i18n`이 지정된 텍스트 메시지와 `i18-n`이 지정된 어트리뷰트를 추출해서 번역 소스 파일로 생성할 수 있습니다.
번역 소스 파일을 생성하려면 터미널 창에서 애플리케이션 최상위 폴더로 이동한 뒤에 Angular CLI `xi18n` 명령을 실행하면 됩니다.

<code-example language="sh" class="code-shell">
  ng xi18n
</code-example>

<!--
By default, the command creates a file named `messages.xlf` in your `src/` folder. 
-->
기본적으로 이 명령을 실행하면 `src/` 폴더에 `messages.xlf` 파일을 생성합니다.

<div class="alert is-helpful">

<!--
If you don't use the CLI, you have two options:
* You can use the `ng-xi18n` tool directly from the `@angular/compiler-cli` package.
For more information, see the [`ng xi18n` command documentation](cli/xi18n).
* You can use the CLI Webpack plugin `AngularCompilerPlugin` from the `@ngtools/webpack` package.
Set the parameters `i18nOutFile` and `i18nOutFormat` to trigger the extraction.
For more information, see the [Angular Ahead-of-Time Webpack Plugin documentation](https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack).
-->
Angular CLI를 사용하지 않는 방법이 두 가지 있습니다:

* 첫번째는 `@angular/compiler-cli` 패키지에 있는 `ng-xi18n` 툴을 직접 실행하는 것입니다.
자세한 내용은 [`ng xi18n` 커맨드 문서](cli/xi18n)를 참고하세요.

* 다른 방법은 `@ngtools/webpack` 패키지에 있는 `AngularCompilerPlugin` Angular CLI Webpack 플러그인을 사용하는 것입니다.
이 플러그인을 사용하려면 `i18nOutFile`과 `i18nOutFormat`을 지정해야 합니다.
자세한 내용은 [Angular Ahead-of-Time Webpack Plugin 문서](https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack)를 참고하세요.

</div>

{@a other-formats}
<!--
### Output options
-->
### 추출 옵션

<!--
You can supply command options to change the format, the name, the location, and the source locale of the extracted file. 
For example, to create a file in the `src/locale` folder, specify the output path:
-->
추출 파일의 형식, 이름, 위치, 언어를 변경하려면 `xi18n` 명령을 실행하면서 옵션을 지정하면 됩니다.
예를 들어 번역 소스 파일을 `src/locale` 폴더에 생성하려면 다음과 같이 지정하면 됩니다:

<code-example language="sh" class="code-shell">
  ng xi18n --output-path src/locale
</code-example>

<!--
By default, the `xi18n` command generates a translation file named `messages.xlf` in the
<a href="https://en.wikipedia.org/wiki/XLIFF">XML Localization Interchange File Format
(XLIFF, version 1.2)</a>.

The command can read and write files in three translation formats:
* XLIFF 1.2 (default)
* XLIFF 2
* <a href="http://cldr.unicode.org/development/development-process/design-proposals/xmb" >XML Message
Bundle (XMB)</a>

You can specify the translation format explicitly with the `--i18nFormat` command option, as illustrated in
these example commands:
-->
기본 옵션으로 `xi18n` 명령을 실행하면 번역 소스 파일 `messages.xlf`는 <a href="https://en.wikipedia.org/wiki/XLIFF">XML Localization Interchange File Format
(XLIFF, version 1.2)</a> 타입으로 생성됩니다.

그리고 Angular CLI는 다음 세 종류의 번역 형식을 인식할 수 있습니다:
* XLIFF 1.2 (default)
* XLIFF 2
* <a href="http://cldr.unicode.org/development/development-process/design-proposals/xmb" >XML Message
Bundle (XMB)</a>

번역 소스 파일의 형식을 명시적으로 지정하려면 `--i18nFormat` 옵션을 사용하면 됩니다.
세 종류의 형식은 각각 다음과 같이 지정합니다:

<code-example language="sh" class="code-shell">
ng xi18n  --i18n-format=xlf
ng xi18n  --i18n-format=xlf2
ng xi18n  --i18n-format=xmb
</code-example>

<!--
The sample in this guide uses the default XLIFF 1.2 format.
-->
이 문서에서는 기본값인 XLIFF 1.2 형식으로 생성된 소스 파일을 기준으로 설명합니다.

<div class="alert is-helpful">

  <!--
  XLIFF files have the extension .xlf. The XMB format generates .xmb source files but uses
  .xtb (XML Translation Bundle: XTB) translation files.
  -->
  XLIFF 포맷 파일의 확장자는 .xlf입니다. 그리고 XMB 포맷 파일의 확장자는 .xmb지만 .xtb (XML Translation Bundle: XTB) 번역 파일도 사용합니다.

</div>

<!--
You can change the name of the translation source file that is generated by the extraction tool with
the `--outFile` command option:
-->
번역 소스 파일의 이름은 `--outFile` 옵션을 사용하면 변경할 수 있습니다:

<code-example language="sh" class="code-shell">

  ng xi18n --out-file source.xlf

</code-example>

<!--
You can specify the base locale of your app with the`--i18n-locale` command option:
-->
그리고 `--i18n-locale` 옵션을 사용하면 애플리케이션이 사용할 기본 locale을 지정할 수 있습니다.

<code-example language="sh" class="code-shell">

  ng xi18n --i18n-locale fr

</code-example>

<!--
The extraction tool uses the locale to add the app locale information into your translation source
file. This information is not used by Angular, but external translation tools may need it.
-->
번역 소스 파일을 생성하는 툴은 이렇게 지정한 locale 정보를 앱에 추가하고 번역 소스 파일에도 추가합니다.
이 정보를 Angular가 직접 사용하지는 않지만 다른 번역 툴을 사용할 때 활용할 수도 있습니다.

{@a translate}
<!--
## Translate the source text
-->
## 텍스트 번역하기

<!--
The `ng xi18n` command generates a translation source file named `messages.xlf` in the project `src`
folder.
The next step is to translate the display strings in this source file into language-specific 
translation files. The example in this guide creates a French translation file.
-->
기본 옵션으로 `ng xi18n` 명령을 실행하면 번역 소스 파일 `messages.xlf`가 프로젝트의 `src` 폴더에 생성됩니다.
그러면 이 파일의 내용을 원하는 언어에 맞게 번역하면 됩니다.
이 문서에서 제공하는 예제에서는 프랑스어로 번역했습니다.

{@a localization-folder}
<!--
### Create a localization folder
-->
### 다국어 폴더 생성하기

<!--
Most apps are translated into more than one other language. For this reason, it is standard practice
for the project structure to reflect the entire internationalization effort.

One approach is to dedicate a folder to localization and store related assets, such as
internationalization files, there.
-->
애플리케이션은 보통 하나 이상의 언어로 번역됩니다.
그래서 프로젝트 구조는 다국어를 염두에 두고 준비해야 합니다.
일반적인 방법은 다국어(localization)만을 위한 폴더를 하나 생성하고 이 폴더에 다국어와 관련된 파일(internationalization files)을 모두 모아두는 것입니다.

<div class="alert is-helpful">

  <!--
  Localization and internationalization are
  <a href="https://en.wikipedia.org/wiki/Internationalization_and_localization">different but
  closely related terms</a>.
  -->
  Localization과 Internationalization이 의미하는 것은 <a href="https://en.wikipedia.org/wiki/Internationalization_and_localization">다르지만, 밀접한 관계가 있습니다.</a>

</div>

<!--
This guide follows that approach. It has a `locale` folder under `src/`.
Assets within that folder have a filename extension that matches their associated locale.
-->
이 문서에서도 이 방식을 따릅니다.
`src/` 폴더 밑에 `locale` 폴더를 만들고, 이 폴더에 다국어와 관련된 파일을 모두 모아두겠습니다.
이 때 폴더 안에 있는 파일들은 해당 언어에 맞는 확장자를 붙이는 것이 좋습니다.

<!--
### Create the translation files
-->
### 번역 파일 생성하기

<!--
For each translation source file, there must be at least one language translation file for the
resulting translation.

For this example:

1. Make a copy of the `messages.xlf` file.
2. Put the copy in the `locale` folder.
3. Rename the copy to `messages.fr.xlf` for the French language translation.

If you were translating to other languages, you would repeat these steps for each target language.
-->
번역 결과물 파일은 번역 소스 파일마다 최소한 1개 이상 존재해야 합니다.

1. `messages.xlf` 파일의 복사본을 만듭니다.
2. 이 파일을 `locale` 폴더로 옮깁니다.
3. 이 파일을 프랑스어로 번역한다면 파일의 이름을 `messages.fr.xlf`로 변경합니다.

이 과정은 번역 소스 파일을 다른 언어로 번역할 때마다 반복해야 합니다.

{@a translate-text-nodes}
<!--
### Translate text nodes
-->
### 텍스트 노드 번역하기

<!--
In a large translation project, you would send the `messages.fr.xlf` file to a French translator who
would enter the translations using an XLIFF file editor.

This sample file is easy to translate without a special editor or knowledge of French.

1. Open `messages.fr.xlf` and find the first `<trans-unit>` section:
-->
번역할 내용이 많다면 `messages.fr.xlf` 파일을 프랑스어 번역자에게 요청할 수도 있으며, 이 번역자는 이 파일을 XLIFF 파일 에디터로 처리할 수도 있습니다.

하지만 이 문서에서 다루는 예제 파일의 내용은 그리 많지 않기 때문에 일반 텍스트 에디터를 사용해도 됩니다.

1. `messages.fr.xlf` 파일을 열고 첫번째 `<trans-unit>` 섹션을 찾습니다:

> <code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-hello-before" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
> This XML element represents the translation of the `<h1>` greeting tag that you marked with the
  `i18n` attribute earlier in this guide.

> Note that the translation unit `id=introductionHeader` is derived from the
  [custom `id`](#custom-id "Set a custom id") that you set earlier, but
  without the `@@` prefix required in the source HTML.
-->
> 이 XML 엘리먼트는 위에서 `i18n` 어트리뷰트를 지정했던 `<h1>` 태그를 표현합니다.

> 위에서 지정했던 [커스텀 `id`](#custom-id "Set a custom id")가 `id=introductionHeader`와 같이 지정된 것도 확인해 보세요. 소스 HTML에 붙였던 `@@` 접두사는 이 파일에 존재하지 않습니다.

<!--
2. Duplicate the `<source/>` tag, rename it `target`, and then replace its content with the French
  greeting. If you were working with a more complex translation, you could use the information
  and context provided by the source, description, and meaning elements to guide your selection of
  the appropriate French translation.

> <code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-hello" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;, after translation)" linenums="false">
</code-example>
-->
2. `<source/>` 태그를 복사하고 새로 만든 태그의 이름을 `target`로 변경합니다. 그리고 이 태그 안에 있는 텍스트를 프랑스어로 변경합니다. 번역하려는 문장이 복잡하다면 `source`나 `description`, `meaning` 엘리먼트에 있는 내용을 참고하면 됩니다.

> <code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-hello" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;, 번역 후)" linenums="false">
</code-example>

<!--
3. Translate the other text nodes the same way:
-->
3. 다른 텍스트 노드도 같은 방식으로 번역합니다:

> <code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-other-nodes" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<div class="alert is-important">

  <!--
  **The Angular i18n tools generated the ids for these translation units. Don't change them.**
  Each `id` depends upon the content of the template text and its assigned meaning.
  If you change either the text or the meaning, then the `id` changes.
  For more information, see the **[translation file maintenance discussion](#custom-id)**.
  -->
  **Angular i18n 툴로 번역할 문구를 추출하면 번역 단위마다 id가 지정됩니다. 이 id는 변경하지 마세요.**
  이 `id`는 템플릿에 사용된 텍스트와 의미에 따라 지정된 것입니다.
  그래서 텍스트의 내용이나 의미를 변경하면 `id`도 변경됩니다.
  자세한 내용은 **[번역 파일 관리](#custom-id)** 섹션을 참고하세요.

</div>

{@a translate-plural-select}
<!--
## Translating plural and select expressions
-->
## 복수 표현식과 대체문구 번역하기

<!--
The _plural_ and _select_ ICU expressions are extracted separately, so they require special attention
when preparing for translation.

Look for these expressions in relation to other translation units that you recognize from
elsewhere in the source template. In this example, you know the translation unit for the `select`
must be just below the translation unit for the logo.
-->
_복수(plural)_ 표현식과 _대체문구 선택(select)_ ICU 표현식은 별개 번역 단위로 추출됩니다.
그래서 이 표현식들을 번역할 때는 특히 주의해야 합니다.

이 표현식들은 소스 템플릿에 존재하는 번역 단위 근처에 생성되기 때문에 금방 찾을 수 있습니다.
그래서 지금 다루는 예제에서는 로고에 해당하는 번역 단위 바로 밑에 `select` 번역 단위가 존재합니다.

{@a translate-plural}
<!--
### Translate _plural_
-->
### _복수 표현식_ 번역하기

<!--
To translate a `plural`, translate its ICU format match values:
-->
복수 표현식(`plural`)을 번역하려면 해당 문구를 ICU 포맷에 맞게 다음과 같이 번역해야 합니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-plural" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
You can add or remove plural cases, with each language having its own cardinality.  (See
[CLDR plural rules](http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html).)
-->
복수 표현식은 번역하려는 언어에 따라 자유롭게 추가되거나 생략할 수 있습니다.
([CLDR 복수표현식 규칙](http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html)을 참고하세요.)

{@a translate-select}
<!--
### Translate _select_
-->
### _대체 문구_ 번역하기

<!--
Below is the content of our example `select` ICU expression in the component template:
-->
아래 코드는 `select` ICU 표현식이 사용된 컴포넌트 템플릿의 일부입니다:

<code-example path="i18n/src/app/app.component.html" region="i18n-select" header="src/app/app.component.html" linenums="false">
</code-example>

<!--
The extraction tool broke that into two translation units because ICU expressions are extracted
separately.

The first unit contains the text that was outside of the `select`.
In place of the `select` is a placeholder, `<x id="ICU">`, that represents the `select` message.
Translate the text and move around the placeholder if necessary, but don't remove it. If you remove
the placeholder, the ICU expression will not be present in your translated app.
-->
이 태그는 2개의 번역 단위로 분리됩니다. 왜냐하면 ICU 표현식에서 대체 문구는 별개로 표현되기 때문입니다.

첫번째 번역 단위는 대체 문구 표현식(`select`) 외부에 있는 텍스트입니다.
이 번역 단위에서 `select`가 있던 자리에는 대체 문구를 대신해서 `<x id="ICU">`가 들어갑니다.
번역을 진행하면서 다른 텍스트는 수정해도 되고 `<x>` 태그의 위치르 옮겨도 되지만, 이 태그를 제거하면 안됩니다.
이 태그를 제거하면 ICU 표현식이 화면에 표시되지 않습니다.

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translate-select-1" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
The second translation unit, immediately below the first one, contains the `select` message.
Translate that as well.
-->
두번째 번역 단위는 첫번째 번역 단위 바로 밑에 존재하는데, 이 번역 단위에는 대체 표현식 안에 있는 메시지가 들어있습니다.
이 문장도 해당 언어에 맞게 번역하면 됩니다.

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translate-select-2" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
Here they are together, after translation:
-->
이 작업을 끝내면 다음과 같은 번역 파일이 될 것입니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translated-select" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

{@a translate-nested}
<!--
### Translate a nested expression
-->
### 중첩된 표현식 번역하기

<!--
A nested expression is similar to the previous examples. As in the previous example, there are
two translation units. The first one contains the text outside of the nested expression:
-->
중첩된 표현식도 지금까지 살펴봤던 예제와 비슷합니다.
이전 예제와 마찬가지로, 중첩된 표현식도 여러개의 번역 단위로 분리됩니다.
첫번째 번역 단위에는 중첩된 표현식 밖에 있는 텍스트가 존재합니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translate-nested-1" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
The second unit contains the complete nested expression:
-->
그리고 두번째 번역 단위에는 중첩된 표현식의 내용물이 들어갑니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translate-nested-2" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
And both together:
-->
두 번역 단위를 모두 번역하고 나면 다음과 같이 될 것입니다:

<code-example path="i18n/doc-files/messages.fr.xlf.html" region="translate-nested" header="src/locale/messages.fr.xlf (&lt;trans-unit&gt;)" linenums="false">
</code-example>

<!--
The entire template translation is complete. The next section describes how to load that translation
into the app.
-->
이제 템플릿 번역은 끝났습니다.
다음 섹션에서는 이렇게 만든 번역 파일을 애플리케이션에 어떻게 적용할 수 있는지 알아봅시다.

{@a app-pre-translation}
<!--
### The app and its translation file
-->
### 번역 결과물

<!--
The sample app and its translation file are now as follows:
-->
이제 예제 애플리케이션과 번역 파일의 내용은 다음과 같습니다:

<code-tabs>
  <code-pane header="src/app/app.component.html" path="i18n/src/app/app.component.html">
  </code-pane>
  <code-pane header="src/app/app.component.ts" path="i18n/src/app/app.component.ts">
  </code-pane>
  <code-pane header="src/app/app.module.ts" path="i18n/src/app/app.module.ts">
  </code-pane>
  <code-pane header="src/main.ts" path="i18n/doc-files/main.1.ts">
  </code-pane>
  <code-pane header="src/locale/messages.fr.xlf" path="i18n/doc-files/messages.fr.xlf.html">
  </code-pane>
</code-tabs>

{@a merge}
## Merge the completed translation file into the app

To merge the translated text into component templates, compile the app with the completed
translation file.

 Provide the Angular compiler with three translation-specific pieces of information:

  * The translation file.
  * The translation file format.
  * The locale (`fr` or `en-US` for instance).

The compilation process is the same whether the translation file is in `.xlf` format or in another
format that Angular understands, such as `.xtb`.

How you provide this information depends upon whether you compile with
the JIT compiler or the AOT compiler.

  * With [AOT](guide/i18n#merge-aot), you pass the information as configuration settings.
  * With [JIT](guide/i18n#merge-jit), you provide the information at bootstrap time.


{@a merge-aot}
### Merge with the AOT compiler

The [AOT compiler](guide/glossary#aot) is part of a build process that produces a small, fast,
ready-to-run application package, typically for production.

When you internationalize with the AOT compiler, you must pre-build a separate application
package for each language and serve the appropriate package based on either server-side language
detection or url parameters.

To instruct the AOT compiler to use your translation configuration, set the three "i18n" build configuration options in your `angular.json` file.

* `i18nFile`: the path to the translation file.
* `i18nFormat`: the format of the translation file.
* `i18nLocale`: the locale id.

You should also direct the output to a locale-specific folder to keep it separate from other locale versions of your app, by setting the `outputPath` configuration option.

```
"build": {
  ...
  "configurations": {
    ...
    "fr": {
      "aot": true,
      "outputPath": "dist/my-project-fr/",
      "i18nFile": "src/locale/messages.fr.xlf",
      "i18nFormat": "xlf",
      "i18nLocale": "fr",
      ...
    }
  }
},
"serve": {
  ...
  "configurations": {
    ...
    "fr": {
      "browserTarget": "*project-name*:build:fr"
    }
  }
}
```

You can then pass this configuration to the `ng serve` or `ng build` commands.
The example below shows how to serve the French language file created in previous
sections of this guide:

<code-example language="sh" class="code-shell">
  ng serve --configuration=fr
</code-example>

For production builds, you define a separate `production-fr` build configuration in
the CLI configuration file, `angular.json`.

```
...
"architect": {
  "build": {
    "builder": "@angular-devkit/build-angular:browser",
    "options": { ... },
    "configurations": {
      "fr": {
        "aot": true,
        "outputPath": "dist/my-project-fr/",
        "i18nFile": "src/locale/messages.fr.xlf",
        "i18nFormat": "xlf",
        "i18nLocale": "fr",
        "i18nMissingTranslation": "error",
      }
// ...
"serve": {
  "builder": "@angular-devkit/build-angular:dev-server",
  "options": {
    "browserTarget": "my-project:build"
  },
  "configurations": {
    "production": {
      "browserTarget": "my-project:build:production"
    },
    "fr": {
      "browserTarget": "my-project:build:fr"
    }
  }
},

```

The same configuration options can also be provided through the CLI with your existing `production` configuration.

<code-example language="sh" class="code-shell">
  ng build --prod --i18n-file src/locale/messages.fr.xlf --i18n-format xlf --i18n-locale fr
</code-example>

{@a merge-jit}
### Merge with the JIT compiler

The [JITcompiler](guide/glossary#jit) compiles your app in the browser as the app loads.
To support translation with the JIT compiler, you must do the following:

1. Import the appropriate language translation file as a string constant.
2. Create corresponding translation providers for the JIT compiler.
3. Bootstrap the app with those providers.

Three providers tell the JIT compiler how to translate the template texts for a particular language
while compiling the app:

* `TRANSLATIONS` is a string containing the content of the translation file.
* `TRANSLATIONS_FORMAT` is the format of the file: `xlf`, `xlf2`, or `xtb`.
* `LOCALE_ID` is the locale of the target language.

The Angular `bootstrapModule` method has a second `compilerOptions` parameter that can influence the
behavior of the compiler. You can use it to specify the translation providers:

<code-example path="i18n/doc-files/main.2.ts" header="src/main.ts">
</code-example>

Then provide the `LOCALE_ID` in the main module:

<code-example path="i18n/doc-files/app.module.ts" header="src/app/app.module.ts" linenums="false">
</code-example>


{@a missing-translation}
### Report missing translations
By default, when a translation is missing, the build succeeds but generates a warning such as
`Missing translation for message "foo"`. You can configure the level of warning that is generated by
the Angular compiler:

* Error: throw an error. If you are using AOT compilation, the build will fail. If you are using JIT
compilation, the app will fail to load.
* Warning (default): show a 'Missing translation' warning in the console or shell.
* Ignore: do nothing.

You specify the warning level in the `configurations` section your Angular CLI build configuration. The example below shows how to set the warning level to error:

```
"configurations": {
  ...
  "fr": {
    ...
    "i18nMissingTranslation": "error"
  }
}
```

If you use the JIT compiler, specify the warning level in the compiler config at bootstrap by adding
the 'MissingTranslationStrategy' property. The example below shows how to set the warning level to
error:

<code-example path="i18n/doc-files/main.3.ts" header="src/main.ts">
</code-example>

### Build for multiple locales

When you use the CLI `build` or `serve` command to build your application for different locales, change the output path using the `--outputPath` command option (along with the i18n-specific command options), so that the translation files are saved to different locations.
When you are serving a locale-specific version from a subdirectory, you can also change the base URL used by your app by specifying the `--baseHref` option.

For example, if the French version of your application is served from https://myapp.com/fr/, configure the build for the French version as follows.

```
"configurations": {
  "fr": {
    "aot": true,
    "outputPath": "dist/my-project-fr/",
    "baseHref": "/fr/",
    "i18nFile": "src/locale/messages.fr.xlf",
    "i18nFormat": "xlf",
    "i18nLocale": "fr",
    "i18nMissingTranslation": "error",
  }
```

For more details about how to create scripts to generate an app in multiple languages and how to set up Apache 2 to serve them from different subdirectories, read [this tutorial by Philippe Martin](https://medium.com/@feloy/deploying-an-i18n-angular-app-with-angular-cli-fc788f17e358#.1xq4iy6fp).
