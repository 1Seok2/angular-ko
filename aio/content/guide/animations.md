<!--
# Animations
-->
# 애니메이션

<!--
Motion is an important aspect in the design of modern web applications. Good
user interfaces transition smoothly between states with engaging animations
that call attention where it's needed. Well-designed animations can make a UI not only
more fun but also easier to use.
-->
요즘은 웹 애플리케이션 디자인에 애니메이션을 활용하는 것도 중요합니다.
사용자가 어떤 행동을 했을 때 적절한 애니메이션이 보여진다면 사용자가 어떤 곳에 주목해야 하는지 좀 더 풍부한 정보를 제공할 수 있기 때문입니다.
그렇다면 애니메이션은 UI를 재미있게 할 뿐만 아니라 애플리케이션 사용을 돕는 측면에서도 중요합니다.

<!--
## Overview
-->
## 개요

<!--
Angular's animation system lets you build animations that run with the same kind of native
performance found in pure CSS animations. You can also tightly integrate your
animation logic with the rest of your application code, for ease of control.
-->
Angular에서 제공하는 애니메이션 성능은 순수한 CSS를 활용한 네이티브 애니메이션 성능과 비슷한 수준입니다.
그리고 Angular 애니메이션을 활용하면 애플리케이션 코드에서도 애니메이션을 쉽게 조작할 수 있습니다.

<div class="alert is-helpful">

<!--
Angular animations are built on top of the standard [Web Animations API](https://w3c.github.io/web-animations/)
and run natively on [browsers that support it](http://caniuse.com/#feat=web-animation).
-->
Angular 애니메이션은 [웹 애니메이션 API](https://w3c.github.io/web-animations/) 표준을 바탕으로 구현되었으며, [이 표준을 지원하는 브라우저](http://caniuse.com/#feat=web-animation)에서는 네이티브 성능으로 동작합니다.

<!--
As of Angular 6, If the Web Animations API is not supported natively by the browser, then Angular will use CSS
keyframes as a fallback instead (automatically). This means that the polyfill is no longer required unless any
code uses [AnimationBuilder](/api/animations/AnimationBuilder). If your code does use AnimationBuilder, then
uncomment the `web-animations-js` polyfill from the `polyfills.ts` file generated by Angular CLI.
-->
Angular 6버전부터는 브라우저가 네이티브로 웹 애니메이션 API를 지원하지 않으면, CSS 키프레임을 활용하는 방식으로 자동 변경됩니다.
그래서 [AnimationBuilder](/api/animations/AnimationBuilder)를 사용하지 않는 이상 애니메이션 폴리필은 더이상 사용되지 않지 않습니다.
코드에서 이미 AnimationBuilder를 사용하고 있다면, Angular CLI가 만든 `polyfills.ts` 파일에서 `web-animation-js` 폴리필을 제거하기만 하면 새로운 방식으로 동작합니다.

</div>

<div class="l-sub-section">

<!--
The examples in this page are available as a <live-example></live-example>.
-->
이 문서에서 다루는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.

</div>

<!--
## Setup
-->
## 환경 설정

<!--
Before you can add animations to your application, you need
to import a few animation-specific modules and functions to the root application module.
-->
애플리케이션에 애니메이션을 적용하려면 애플리케이션 루트 모듈에 애니메이션 관련 모듈을 추가해야 합니다.

<code-example path="animations/src/app/app.module.ts" region="animations-module" title="app.module.ts (animation module import excerpt)" linenums="false"></code-example>

<!--
#### Example basics
-->
#### 기본 예제

<!--
The animations examples in this guide animate a list of heroes.

A `Hero` class has a `name` property, a `state` property that indicates if the hero is active or not,
and a `toggleState()` method to switch between the states.
-->
이제 히어로의 목록을 표시하는 화면에 애니메이션을 적용해 봅시다.

`Hero` 클래스에는 `name` 프로퍼티가 있으며, `state` 프로퍼티는 이 히어로가 활성화된 상태인지 아닌지를 표현합니다. 그리고 `toggleState()` 메소드는 이 활성화 상태를 전환합니다.

<code-example path="animations/src/app/hero.service.ts" region="hero" title="hero.service.ts (Hero class)" linenums="false"></code-example>

<!--
Across the top of the screen (`app.hero-team-builder.component.ts`)
are a series of buttons that add and remove heroes from the list (via the `HeroService`). 
The buttons trigger changes to the list that all of the example components see at the same time.
-->
화면 위쪽(`app.hero-team-builder.component.ts`)에는 `HeroService`를 통해 히어로를 추가하고 제거하는 버튼이 몇 개 있습니다.
이 버튼들은 이 문서에서 다루는 예제에서 다양하게 활용됩니다.

{@a example-transitioning-between-states}

<!--
## Transitioning between two states
-->
## 두가지 상태(state) 전환하기

<img src="generated/images/guide/animations/animation_basic_click.gif" alt="A simple transition animation" class="right">

<!--
You can build a simple animation that transitions an element between two states
driven by a model attribute.
-->
엘리먼트에 모델 어트리뷰트를 지정하고 이 어트리뷰트에 연결된 애니메이션 상태를 전환하면 간단한 애니메이션을 구현할 수 있습니다.

<!--
Animations can be defined inside `@Component` metadata. 
-->
이 때 애니메이션은 `@Component` 메타데이터에 정의합니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="imports" title="hero-list-basic.component.ts" linenums="false"></code-example>

<!--
With these, you can define an *animation trigger* called `heroState` in the component
metadata. It uses animations to transition between two states: `active` and `inactive`. When a
hero is active, the element appears in a slightly larger size and lighter color.
-->
컴포넌트 메타데이터에는 `heroState`라고 이름 붙인 *애니메이션 트리거*를 정의합니다.
그리고 이 애니메이션 트리거는 `active` 상태와 `inactive` 상태로 전환되면서 애니메이션에 적용됩니다.
히어로의 상태가 `active`가 되면 엘리먼트가 약간 커지고 밝은 색상으로 변경될 것입니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="animationdef" title="hero-list-basic.component.ts (@Component excerpt)" linenums="false"></code-example>

<div class="alert is-helpful">

<!--
In this example, you are defining animation styles (color and transform) inline in the
animation metadata.
-->
이 예제는 애니메이션 메타데이터에 애니메이션 스타일(색상, 크기)을 인라인으로 지정했습니다.

</div>

<!--
Now, using the `[@triggerName]` syntax, attach the animation that you just defined to
one or more elements in the component's template.
-->
그리고 컴포넌트 템플릿에 있는 엘리먼트에 `[@트리거_이름]`을 지정해서 애니메이션을 적용합니다. 애니메이션 트리거는 한 엘리먼트, 또는 여러 엘리먼트에 동시에 지정할 수 있습니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="template" title="hero-list-basic.component.ts (excerpt)" linenums="false"></code-example>

<!--
Here, the animation trigger applies to every element repeated by an `ngFor`. Each of
the repeated elements animates independently. The value of the
attribute is bound to the expression `hero.state` and is always either `active` or `inactive`.

With this setup, an animated transition appears whenever a hero object changes state.
Here's the full component implementation:
-->
이제 애니메이션 트리거는 `ngFor`로 반복되는 모든 엘리먼트에 적용됩니다.
각각의 엘리먼트에서 동작하는 애니메이션은 서로 독립적입니다.
그리고 `hero.state`에 할당되는 값은 반드시 `active`이거나 `inactive`여야 합니다.

이렇게 구현하면 히어로 객체의 상태가 변경될때마다 애니메이션이 실행됩니다.
이 컴포넌트의 전체 코드는 다음과 같습니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" title="hero-list-basic.component.ts"></code-example>

<!--
## States and transitions
-->
## 상태와 트랜지션

<!--
Angular animations are defined as logical **states** and **transitions**
between states.

An animation state is a string value that you define in your application code. In the example
above, the states `'active'` and `'inactive'` are based on the logical state of
hero objects. The source of the state can be a simple object attribute, as it was in this case,
or it can be a value computed in a method. The important thing is that you can read it into the
component's template.

You can define *styles* for each animation state:
-->
Angular 애니메이션은 논리적으로 전환되는 **상태(state)**와 이 상태간 전환을 뜻하는 **트랜지션(transition)** 으로 정의합니다.

애니메이션 상태는 문자열로 정의하며, 애플리케이션 코드에서 지정합니다. 그래서 위 예제에서는 `'active'` 상태와 `'inactive'` 상태를 히어로 객체 안에서 지정했습니다. 상태값을 표현하는 문자열은 이 예제처럼 객체 안에 있는 프로퍼티 일수도 있고, 메소드의 실행결과로 반환되는 값일 수도 있습니다. 이 값은 컴포넌트의 템플릿에서 접근할수만 있으면 어떤 것이든 상관없습니다.

각 애니메이션 상태는 *스타일 객체*로 정의할 수도 있습니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" region="states" title="src/app/hero-list-basic.component.ts" linenums="false"></code-example>

<!--
These `state` definitions specify the *end styles* of each state.
They are applied to the element once it has transitioned to that state, and stay
*as long as it remains in that state*. In effect, you're defining what styles the element has in different states.

After you define states, you can define *transitions* between the states. Each transition
controls the timing of switching between one set of styles and the next:
-->
이렇게 `state`에 지정하는 스타일은 각 상태의 *최종 스타일* 입니다.
상태에 지정된 스타일은 해당 엘리먼트가 이 상태로 전환된 시점부터 적용되기 시작하며, *다른 상태로 바뀌기 전까지* 계속 적용됩니다.

상태를 적용한 뒤에는 이 상태를 전환하는 *트랜지션*을 정의합니다.
각각의 트랜지션은 전환되는 상태와 애니메이션 타이밍으로 구성되며, 다음과 같이 정의합니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" region="transitions" title="src/app/hero-list-basic.component.ts" linenums="false"></code-example>

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active.png" alt="In Angular animations you define states and transitions between states" width="400">
</figure>

<!--
If several transitions have the same timing configuration, you can combine
them into the same `transition` definition:
-->
그리고 여러 트랜지션에 같은 타이밍 효과를 지정하려면 다음과 같이 지정합니다:

<code-example path="animations/src/app/hero-list-combined-transitions.component.ts" region="transitions" title="src/app/hero-list-combined-transitions.component.ts" linenums="false"></code-example>

<!--
When both directions of a transition have the same timing, as in the previous
example, you can use the shorthand syntax `<=>`:
-->
이전 예제처럼 트랜지션이 양방향으로 적용된다면 간단하게 `<=>`라고 표현할 수도 있습니다:

<code-example path="animations/src/app/hero-list-twoway.component.ts" region="transitions" title="src/app/hero-list-twoway.component.ts" linenums="false"></code-example>

<!--
You can also apply a style during an animation but not keep it around
after the animation finishes. You can define such styles inline, in the `transition`. In this example,
the element receives one set of styles immediately and is then animated to the next.
When the transition finishes, none of these styles are kept because they're not
defined in a `state`.
-->
그리고 애니메이션 트랜지션이 진행되는 중에 적용될 스타일도 지정할 수 있습니다.
마찬가지로 이 스타일도 인라인으로 정의하거나 `transition`에 정의할 수 있으며, 이 스타일은 트랜지션이 시작될 때 바로 적용됩니다.
그리고 트랜지션이 종료되면 `state`에 지정되지 않은 스타일은 모두 해제됩니다.

<code-example path="animations/src/app/hero-list-inline-styles.component.ts" region="transitions" title="src/app/hero-list-inline-styles.component.ts" linenums="false"></code-example>

<!--
### The wildcard state `*`
-->
### 모든 상태 `*`

<!--
The `*` ("wildcard") state matches *any* animation state. This is useful for defining styles and
transitions that apply regardless of which state the animation is in. For example:
-->
모든 상태(wildcard state)라고 하는 `*` 상태는 *모든* 애니메이션 상태와 매칭됩니다. 이 상태는 모든 애니메이션에 같은 스타일과 같은 트랜지션 효과를 정의할 때 사용합니다. 예를 들면:

<!--
* The `active => *` transition applies when the element's state changes from `active` to anything else.
* The `* => *` transition applies when *any* change between two states takes place.
-->
* `active => *` 트랜지션은 `active` 상태에서 다른 모든 상태로 전환될 때 적용됩니다.
* `* => *` 트랜지션은 *모든* 트랜지션에 적용됩니다.

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active_wildcards.png" alt="The wildcard state can be used to match many different transitions at once" width="400">
</figure>

<!--
### The `void` state
-->
### `void` 상태

<!--
The special state called `void` can apply to any animation. It applies
when the element is *not* attached to a view, perhaps because it has not yet been
added or because it has been removed. The `void` state is useful for defining enter and
leave animations.
-->
또 다른 특별 상태인 `void`를 활용할 수도 있습니다. 이 상태는 아직 뷰에 추가되지 않았거나, 뷰에서 사라진 직후의 엘리먼트, 즉 뷰에 *존재하지 않는* 엘리먼트에 적용되며, 이 상태를 활용하면 엘리먼트가 나타나거나 사라지는 애니메이션을 구현할 때 유용합니다.

<!--
For example the `* => void` transition applies when the element leaves the view,
regardless of what state it was in before it left.
-->
예를 들어 `* => void` 트랜지션은 이전의 상태와 관계없이 뷰에서 사라지는 엘리먼트에 모두 적용됩니다.

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_void_in.png" alt="The void state can be used for enter and leave transitions" width="400">
</figure>

<!--
The wildcard state `*` also matches `void`.
-->
모든 상태를 의미하는 `*`는 `void` 상태에도 적용됩니다.

<!--
## Example: Entering and leaving
-->
## 예제 : 나타날 때, 사라질 때

<img src="generated/images/guide/animations/animation_enter_leave.gif" alt="Enter and leave animations" class="right" width="250">

<!--
Using the `void` and `*` states you can define transitions that animate the
entering and leaving of elements:

* Enter: `void => *`
* Leave: `* => void`

For example, in the `animations` array below there are two transitions that use
the `void => *` and `* => void` syntax to animate the element in and out of the view.
-->
`void` 상태와 `*` 상태를 사용하면 엘리먼트가 나타나거나 사라지는 애니메이션을 구현할 수 있습니다:

* 나타날 때 : `void => *`
* 사라질 때 : `* => void`

그래서 아래 코드는 두 상황에 대한 트랜지션 효과를 각각 정의하고 있습니다.

<code-example path="animations/src/app/hero-list-enter-leave.component.ts" region="animationdef" title="hero-list-enter-leave.component.ts (excerpt)" linenums="false"></code-example>

<!--
Note that in this case the styles are applied to the void state directly in the
transition definitions, and not in a separate `state(void)` definition. Thus, the transforms
are different on enter and leave: the element enters from the left
and leaves to the right.
-->
이 코드에서는 `void` 상태에 적용되는 스타일을 `state(void)`로 지정하지 않고 트랜지션 정의에 직접 지정했습니다.
그래서 엘리먼트가 나타날 때와 사라질 때 효과가 다르며, 엘리먼트가 나타날 때는 왼쪽부터 나타나고, 엘리먼트가 사라질 때는 오른쪽으로 사라집니다.

<div class="l-sub-section">

<!--
These two common animations have their own aliases:
-->
이 트랜지션 정의는 다음과 같이 정의할 수도 있습니다:

<code-example language="typescript">
  transition(':enter', [ ... ]); // void => *
  transition(':leave', [ ... ]); // * => void
</code-example>

</div>

<!--
## Example: Entering and leaving from different states
-->
## 예제 : 특정 상태로 전환될 때, 특정 상태에서 다른 상태로 전환될 때

<img src="generated/images/guide/animations/animation_enter_leave_states.gif" alt="Enter and leave animations combined with state animations" class="right" width="200">

<!--
You can also combine this animation with the earlier state transition animation by
using the hero state as the animation state. This lets you configure
different transitions for entering and leaving based on what the state of the hero
is:

* Inactive hero enter: `void => inactive`
* Active hero enter: `void => active`
* Inactive hero leave: `inactive => void`
* Active hero leave: `active => void`

This gives you fine-grained control over each transition:
-->
`void` 상태는 이전 예제에서 살펴본 다른 상태와도 함께 적용할 수 있습니다.
히어로 엘리먼트에 `active` 상태와 `inactive` 상태를 정의하면서, 이 엘리먼트가 나타나고 사라지는 애니메이션을 추가로 정의한다면 다음과 같이 정의할 수 있습니다:

* 비활성화 상태의 히어로가 나타날 때 : `void => inactive`
* 활성화 상태의 히어로가 나타날 때 : `void => active`
* 비활성화 상태의 히어로가 사라질 때 : `inactive => void`
* 활성화 상태의 히어로가 사라질 때 : `active => void`

이 트랜지션 관계를 그림으로 표현하면 다음과 같습니다:

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active_void.png" alt="This example transitions between active, inactive, and void states" width="400">
</figure>

<code-example path="animations/src/app/hero-list-enter-leave-states.component.ts" region="animationdef" title="hero-list-enter-leave.component.ts (excerpt)" linenums="false"></code-example>

<!--
## Animatable properties and units
-->
## 애니메이션 프로퍼티, 단위

<!--
Since Angular's animation support builds on top of Web Animations, you can animate any property
that the browser considers *animatable*. This includes positions, sizes, transforms, colors,
borders, and many others. The W3C maintains
[a list of animatable properties](https://www.w3.org/TR/css3-transitions/#animatable-properties)
on its [CSS Transitions page](https://www.w3.org/TR/css3-transitions).
-->
Angular로 구현하는 애니메이션은 웹 애니메이션 표준을 바탕으로 하기 때문에 브라우저가 *애니메이션을 적용할 수 있는* 프로퍼티에는 모두 애니메이션을 적용할 수 있습니다.
여기에는 위치, 크기, transform 속성, 색상, 외곽선 등이 해당됩니다.
[CSS 트랜지션 문서](https://www.w3.org/TR/css3-transitions)에 있는 [애니메이션을 적용할 수 있는 프로퍼티 목록](https://www.w3.org/TR/css3-transitions/#animatable-properties)을 참고하세요.

<!--
For positional properties that have a numeric value, you can define a unit by providing
the value as a string with the appropriate suffix:
-->
이 중에서 위치 프로퍼티는 숫자값에 적당한 단위를 붙여서 다음과 같이 지정할 수 있습니다:

* `'50px'`
* `'3em'`
* `'100%'`

<!--
If you don't provide a unit when specifying dimension, Angular assumes the default of `px`:
-->
단위를 생략하고 숫자값을 지정했을 때 Angular가 기본으로 적용하는 단위는 `px`입니다:

<!--
* `50` is the same as saying `'50px'`
-->
* `50`은 `'50px'`과 같습니다.

<!--
## Automatic property calculation
-->
## 프로퍼티 자동 계산

<img src="generated/images/guide/animations/animation_auto.gif" alt="Animation with automated height calculation" class="right" width="220">

<!--
Sometimes you don't know the value of a dimensional style property until runtime.
For example, elements often have widths and heights that
depend on their content and the screen size. These properties are often tricky
to animate with CSS.

In these cases, you can use a special `*` property value so that the value of the
property is computed at runtime and then plugged into the animation.

In this example, the leave animation takes whatever height the element has before it
leaves and animates from that height to zero:
-->
어떤 경우에는 앱을 실행된 후에야 스타일의 특정값을 지정할 수 있는 경우가 있습니다.
예를 들면, 내용이나 스크린 사이즈에 따라 너비와 높이가 변하는 엘리먼트가 그렇습니다.
그래서 엘리먼트의 너비나 높이에 애니메이션을 적용할 때는 CSS를 활용하기도 합니다.

이런 경우에는 Angular에서 제공하는 `*` 프로퍼티를 사용할 수 있습니다. 이 프로퍼티의 값은 실행된 이후에 Angular에 의해 할당되며, 애니메이션에도 자동으로 반영됩니다.

그래서 화면에서 사라지는 애니메이션을 엘리먼트에 적용하는데, 이 엘리먼트의 이전 높이에 관계없이 그 높이부터 0으로 변하는 애니메이션을 구현하려면 다음과 같이 작성할 수 있습니다:

<code-example path="animations/src/app/hero-list-auto.component.ts" region="animationdef" title="src/app/hero-list-auto.component.ts" linenums="false"></code-example>

<!--
## Animation timing
-->
## 애니메이션 타이밍

<!--
There are three timing properties you can tune for every animated transition:
the duration, the delay, and the easing function. They are all combined into
a single transition *timing string*.
-->
애니메이션 트랜지션에 적용할 수 있는 타이밍 프로퍼티는 재생 시간, 딜레이, 가속도 함수가 있습니다. 이 프로퍼티는 트랜지션을 정의할 때 *타이밍 문자열*로 한 번에 지정합니다.

<!--
### Duration
-->
### 재생 시간(Duration)

<!--
The duration controls how long the animation takes to run from start to finish.
You can define a duration in three ways:

* As a plain number, in milliseconds: `100`
* In a string, as milliseconds: `'100ms'`
* In a string, as seconds: `'0.1s'`
-->
재생 시간은 애니메이션이 시작될 때부터 종료될 때까지를 뜻하며, 다음과 같이 지정할 수 있습니다:

* ms단위 숫자로 : `100`
* ms단위 문자열로 : `'100ms'`
* s단위 문자열 : `'0.1s'`

<!--
### Delay
-->
### 딜레이(delay)

<!--
The delay controls the length of time between the animation trigger and the beginning
of the transition. You can define one by adding it to the same string
following the duration. It also has the same format options as the duration:

* Wait for 100ms and then run for 200ms: `'0.2s 100ms'`
-->
딜레이는 트랜지션이 시작된 후부터 애니메이션이 시작될 때까지 지연되는 시간을 뜻합니다. 이 값은 재생 시간과 마찬가지로 문자열로 설정하며, 사용하는 형식도 같습니다:

* 100ms 지연된 후에 200ms 동안 실행하려면 : `'0.2s 100ms'`

<!--
### Easing
-->
### 가속도 함수(easing function)

<!--
The [easing function](http://easings.net/) controls how the animation accelerates
and decelerates during its runtime. For example, an `ease-in` function causes
the animation to begin relatively slowly but pick up speed as it progresses. You
can control the easing by adding it as a *third* value in the string after the duration
and the delay (or as the *second* value when there is no delay):

* Wait for 100ms and then run for 200ms, with easing: `'0.2s 100ms ease-out'`
* Run for 200ms, with easing: `'0.2s ease-in-out'`
-->
[가속도 함수](http://easings.net/)는 애니메이션이 실행될 때 어떻게 가속되고 감속되는지 결정합니다.
하나를 예로 들면, `ease-in` 함수는 애니메이션이 시작될 때는 느리게 재생되고 애니메이션이 진행되면서 점점 빨라지도록 설정합니다.
가속도 함수는 애니메이션 재생 시간과 딜레이 이후에 *세 번째* 값으로 지정합니다. 만약 딜레이가 없다면 *두 번째* 값으로 지정합니다.

* 100ms 지연된 후에 200ms 동안 `ease-out`으로 실행하려면 : `'0.2s 100ms ease-out'`
* 200ms 동안 `ease-in-out`으로 실행하려면 : `'0.2s ease-in-out'`

<img src="generated/images/guide/animations/animation_timings.gif" alt="Animations with specific timings" class="right" width="220">

<!--
### Example
-->
### 예제

<!--
Here are a couple of custom timings in action. Both enter and leave last for
200 milliseconds, that is `0.2s`, but they have different easings. The leave begins after a
slight delay of 10 milliseconds as specified in `'0.2s 10 ease-out'`:
-->
커스텀 타이밍을 적용해 봅시다. 엘리먼트가 나타날 때와 사라질 때는 200ms동안 애니메이션을 실행하기 위해 `0.2s`로 동일하게 지정하지만, 가속도 함수는 다르게 적용합니다. 사라지는 애니메이션은 10ms 지연한 후에 실행하기 위해 `'0.2s 10 ease-out'`로 지정했습니다:

<code-example path="animations/src/app/hero-list-timings.component.ts" region="animationdef" title="hero-list-timings.component.ts (excerpt)" linenums="false"></code-example>

<!--
## Multi-step animations with keyframes
-->
## 키프레임을 활용하는 다단계 애니메이션

<img src="generated/images/guide/animations/animation_multistep.gif" alt="Animations with some bounce implemented with keyframes" class="right" width="220">

<!--
Animation *keyframes* go beyond a simple transition to a more intricate animation
that goes through one or more intermediate styles when transitioning between two sets of styles.

For each keyframe, you specify an *offset* that defines at which point
in the animation that keyframe applies. The offset is a number between zero,
which marks the beginning of the animation, and one, which marks the end.

This example adds some "bounce" to the enter and leave animations with
keyframes:
-->
애니메이션 *키프레임*을 활용하면 좀 더 복잡한 애니메이션을 실행할 수 있으며, 각 단계에 적용될 스타일과 트랜지션 효과도 따로 지정할 수 있습니다.

각각의 프레임은 애니메이션이 시작된 후부터 얼마나 떨어져 있는지 *오프셋(offset)*을 정의하는 방식으로 지정합니다.
이 오프셋은 애니메이션이 시작되는 시점은 0으로 지정하고, 애니메이션이 끝나는 시점은 1로 지정합니다.

그래서 엘리먼트가 화면에 나타나고 사라지는 중간에 *약간 튕기는* 효과를 주려면 다음과 같이 지정합니다:

<code-example path="animations/src/app/hero-list-multistep.component.ts" region="animationdef" title="hero-list-multistep.component.ts (excerpt)" linenums="false"></code-example>

<!--
Note that the offsets are *not* defined in terms of absolute time. They are relative
measures from zero to one. The final timeline of the animation is based on the combination
of keyframe offsets, duration, delay, and easing.

Defining offsets for keyframes is optional. If you omit them, offsets with even
spacing are automatically assigned. For example, three keyframes without predefined
offsets receive offsets `0`, `0.5`, and `1`.
-->
오프셋은 시간 단위로 지정하지 않고 0부터 1 사이의 상대적인 숫자값으로 지정합니다.
그러면 이렇게 지정된 키프레임 오프셋, 재생 시간, 딜레이, 가속도 함수로 전체 애니메이션 세트가 구성됩니다.

키프레임 오프셋을 지정하는 것은 생략할 수 있으며, 오프셋이 생략되면 각각의 오프셋은 균등하게 나누어 집니다. 예를 들어 오프셋 지정 없이 키프레임을 3개 지정하면, 이 키프레임의 오프셋은 각각 `0`, `0.5`, `1`로 지정됩니다.

<!--
## Parallel animation groups
-->
## 애니메이션 그룹 병렬 실행

<img src="generated/images/guide/animations/animation_groups.gif" alt="Parallel animations with different timings, implemented with groups" class="right" width="220px">

<!--
You've seen how to animate multiple style properties at the same time:
just put all of them into the same `style()` definition.

But you may also want to configure different *timings* for animations that happen
in parallel. For example, you may want to animate two CSS properties but use a
different easing function for each one.

For this you can use animation *groups*. In this example, using groups both on
enter and leave allows for two different timing configurations. Both
are applied to the same element in parallel, but run independently of each other:
-->
이전 예제에서 알아본 것처럼, 애니메이션 스타일은 `style()` 함수를 사용해서 동시에 여러 개를 지정할 수 있습니다.

하지만 어떤 경우에는 동시에 다른 *타이밍*으로 실행되는 애니메이션을 적용해야 할 때가 있습니다.
예를 들면 CSS 프로퍼티 2개를 애니메이션으로 조작하면서 또 다른 프로퍼티에 다른 가속도 함수를 적용하는 경우를 생각해 봅시다.

이럴 때 애니메이션 *그룹*을 활용할 수 있습니다. 아래 예제는 엘리먼트가 나타날 때와 사라질 때 서로 다른 타이밍 효과를 사용합니다. 각각의 애니메이션은 동시에 실행되지만 서로 독립적입니다:

<code-example path="animations/src/app/hero-list-groups.component.ts" region="animationdef" title="hero-list-groups.component.ts (excerpt)" linenums="false"></code-example>

<!--
One group animates the element transform and width; the other group animates the opacity.
-->
위 예제에서 애니메이션 그룹 하나는 너비에 애니메이션을 적용하고, 다른 그룹은 투명도에 애니메이션을 적용합니다.

<!--
## Animation callbacks
-->
## 애니메이션 콜백

<!--
A callback is fired when an animation is started and also when it is done.

In the keyframes example, you have a `trigger` called `@flyInOut`. You can hook
those callbacks like this:
-->
애니메이션이 시작된 후와 종료된 후에는 콜백 함수를 실행할 수 있습니다.

`@flyInOut` 트리거에 연결된 애니메이션이 실행되거나 종료된 시점을 활용하려면 다음과 같이 작성합니다:

<code-example path="animations/src/app/hero-list-multistep.component.ts" region="template" title="hero-list-multistep.component.ts (excerpt)" linenums="false"></code-example>

<!--
The callbacks receive an `AnimationEvent` that contains useful properties such as
`fromState`, `toState` and `totalTime`.

Those callbacks will fire whether or not an animation is picked up.
-->
애니메이션 콜백 이벤트는 `AnimationEvent` 타입의 객체이며, 이 객체에는 `fromState`, `toState`, `totalTime`과 같이 애플리케이션 로직에 활용할 수 있는 프로퍼티가 함께 전달됩니다.

이 콜백 함수는 애니메이션이 도중에 중단되어도 실행됩니다.
