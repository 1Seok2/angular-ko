<!--
# Animations
-->
# 애니메이션

<!--
Motion is an important aspect in the design of modern web applications. Good
user interfaces transition smoothly between states with engaging animations
that call attention where it's needed. Well-designed animations can make a UI not only
more fun but also easier to use.
-->
요즘은 웹 애플리케이션 디자인에 애니메이션을 활용하는 것도 중요합니다.
사용자가 어떤 행동을 했을 때 적절한 애니메이션이 보여진다면 사용자가 어떤 곳에 주목해야 하는지 좀 더 풍부한 정보를 제공할 수 있습니다.
결국 애니메이션은 UI를 재미있게 할 뿐만 아니라 애플리케이션 사용을 돕는 측면에서도 중요합니다.

<!--
## Overview
-->
## 개요

<!--
Angular's animation system lets you build animations that run with the same kind of native
performance found in pure CSS animations. You can also tightly integrate your
animation logic with the rest of your application code, for ease of control.
-->
Angular에서 제공하는 애니메이션 성능은 순수한 CSS를 활용한 네이티브 애니메이션 성능과 비슷한 수준입니다.
그리고 Angular 애니메이션을 활용하면 애플리케이션 코드에서도 애니메이션을 쉽게 조작할 수 있습니다.

<div class="alert is-helpful">

<!--
Angular animations are built on top of the standard [Web Animations API](https://w3c.github.io/web-animations/)
and run natively on [browsers that support it](http://caniuse.com/#feat=web-animation).
-->
Angular 애니메이션은 [웹 애니메이션 API](https://w3c.github.io/web-animations/) 표준을 바탕으로 구현되었으며, [브라우저가 지원하면](http://caniuse.com/#feat=web-animation) 네이티브 성능으로 동작합니다.

<!--
As of Angular 6, If the Web Animations API is not supported natively by the browser, then Angular will use CSS
keyframes as a fallback instead (automatically). This means that the polyfill is no longer required unless any
code uses [AnimationBuilder](/api/animations/AnimationBuilder). If your code does use AnimationBuilder, then
uncomment the `web-animations-js` polyfill from the `polyfills.ts` file generated by Angular CLI.
-->
Angular 6버전부터는 브라우저가 네이티브로 웹 애니메이션 API를 지원하지 않으면, CSS 키프레임을 활용하는 방식으로 자동 변경됩니다.
그래서 [AnimationBuilder](/api/animations/AnimationBuilder)를 사용하지 않는 이상 애니메이션 폴리필은 더이상 사용되지 않지 않습니다.
코드에서 이미 AnimationBuilder를 사용하고 있다면, Angular CLI가 만든 `polyfills.ts` 파일에서 `web-animation-js` 폴리필을 제거하기만 하면 새로운 방식으로 동작합니다.

</div>

<div class="l-sub-section">

<!--
The examples in this page are available as a <live-example></live-example>.
-->
이 문서에서 다루는 예제는 <live-example></live-example>에서 직접 확인하거나 다운받아 확인할 수 있습니다.

</div>

<!--
## Setup
-->
## 환경 설정

<!--
Before you can add animations to your application, you need
to import a few animation-specific modules and functions to the root application module.
-->
애플리케이션에 애니메이션을 적용하기 전에, 애플리케이션 루트 모듈에 애니메이션 관련 모듈을 추가해야 합니다.

<code-example path="animations/src/app/app.module.ts" region="animations-module" title="app.module.ts (animation module import excerpt)" linenums="false"></code-example>

<!--
#### Example basics
-->
#### 기본 예제

<!--
The animations examples in this guide animate a list of heroes.

A `Hero` class has a `name` property, a `state` property that indicates if the hero is active or not,
and a `toggleState()` method to switch between the states.
-->
이제 히어로의 목록을 표시하는 화면에 애니메이션을 적용해 봅시다.

`Hero` 클래스에는 `name` 프로퍼티가 있으며, `state` 프로퍼티는 이 히어로가 활성화된 상태인지 아닌지를 표현합니다. 그리고 `toggleState()` 메소드는 이 활성화 상태를 전환합니다.

<code-example path="animations/src/app/hero.service.ts" region="hero" title="hero.service.ts (Hero class)" linenums="false"></code-example>

<!--
Across the top of the screen (`app.hero-team-builder.component.ts`)
are a series of buttons that add and remove heroes from the list (via the `HeroService`). 
The buttons trigger changes to the list that all of the example components see at the same time.
-->
화면 위쪽(`app.hero-team-builder.component.ts`)에는 `HeroService`를 통해 히어로를 추가하고 제거하는 버튼이 몇 개 있습니다.
이 버튼들은 이 문서에서 다루는 예제에서 다양하게 활용됩니다.

{@a example-transitioning-between-states}

<!--
## Transitioning between two states
-->
## 두가지 상태(state) 전환하기

<img src="generated/images/guide/animations/animation_basic_click.gif" alt="A simple transition animation" class="right">

<!--
You can build a simple animation that transitions an element between two states
driven by a model attribute.
-->
엘리먼트에 모델 어트리뷰트를 지정하고 이 어트리뷰트에 연결된 애니메이션 상태를 전환하면 간단한 애니메이션을 구현할 수 있습니다.

<!--
Animations can be defined inside `@Component` metadata. 
-->
이 때 애니메이션은 `@Component` 메타데이터에 정의합니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="imports" title="hero-list-basic.component.ts" linenums="false"></code-example>

<!--
With these, you can define an *animation trigger* called `heroState` in the component
metadata. It uses animations to transition between two states: `active` and `inactive`. When a
hero is active, the element appears in a slightly larger size and lighter color.
-->
컴포넌트 메타데이터에는 `heroState`라고 이름 붙인 *애니메이션 트리거*를 정의합니다.
그리고 이 애니메이션 트리거는 `active` 상태와 `inactive` 상태로 전환되면서 애니메이션에 적용됩니다.
히어로의 상태가 `active`가 되면 엘리먼트가 약간 커지고 밝은 색상으로 변경될 것입니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="animationdef" title="hero-list-basic.component.ts (@Component excerpt)" linenums="false"></code-example>

<div class="alert is-helpful">

<!--
In this example, you are defining animation styles (color and transform) inline in the
animation metadata.
-->
이 예제는 애니메이션 스타일(색상, 크기)를 애니메이션 메타데이터에 인라인으로 지정했습니다.

</div>

<!--
Now, using the `[@triggerName]` syntax, attach the animation that you just defined to
one or more elements in the component's template.
-->
그리고 컴포넌트 템플릿에 있는 엘리먼트에 `[@트리거_이름]`을 지정해서 애니메이션을 적용합니다. 애니메이션 트리거는 한 엘리먼트, 또는 여러 엘리먼트에 동시에 지정할 수 있습니다.

<code-example path="animations/src/app/hero-list-basic.component.ts" region="template" title="hero-list-basic.component.ts (excerpt)" linenums="false"></code-example>

<!--
Here, the animation trigger applies to every element repeated by an `ngFor`. Each of
the repeated elements animates independently. The value of the
attribute is bound to the expression `hero.state` and is always either `active` or `inactive`.

With this setup, an animated transition appears whenever a hero object changes state.
Here's the full component implementation:
-->
이제 애니메이션 트리거는 `ngFor`로 반복되는 모든 엘리먼트에 적용됩니다.
각각의 엘리먼트에서 동작하는 애니메이션은 서로 독립적입니다.
그리고 `hero.state`에 할당되는 값은 반드시 `active`이거나 `inactive`여야 합니다.

이렇게 구현하면 히어로 객체의 상태가 변경될때마다 애니메이션이 실행됩니다.
이 컴포넌트의 전체 코드는 다음과 같습니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" title="hero-list-basic.component.ts"></code-example>

<!--
## States and transitions
-->
## 상태와 트랜지션

<!--
Angular animations are defined as logical **states** and **transitions**
between states.

An animation state is a string value that you define in your application code. In the example
above, the states `'active'` and `'inactive'` are based on the logical state of
hero objects. The source of the state can be a simple object attribute, as it was in this case,
or it can be a value computed in a method. The important thing is that you can read it into the
component's template.

You can define *styles* for each animation state:
-->
Angular 애니메이션은 논리적으로 전환되는 **상태(state)**와 이 상태간 전환을 뜻하는 **트랜지션(transition)** 으로 정의합니다.

애니메이션 상태는 문자열로 정의하며, 애플리케이션 코드에서 지정합니다. 위 예제에서는 `'active'` 상태와 `'inactive'` 상태를 정의하고 히어로 객체에 정의했습니다. 상태값을 표현하는 문자열은 이 예제처럼 객체 안에 있는 프로퍼티 일수도 있고, 메소드의 실행결과로 반환되는 값일 수도 있습니다. 이 값은 컴포넌트의 템플릿에서 접근할수만 있으면 어떤 것이든 상관없습니다.

각 애니메이션 상태는 *스타일 객체*로 정의할 수도 있습니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" region="states" title="src/app/hero-list-basic.component.ts" linenums="false"></code-example>

<!--
These `state` definitions specify the *end styles* of each state.
They are applied to the element once it has transitioned to that state, and stay
*as long as it remains in that state*. In effect, you're defining what styles the element has in different states.

After you define states, you can define *transitions* between the states. Each transition
controls the timing of switching between one set of styles and the next:
-->
이렇게 `state`에 지정하는 스타일은 각 상태의 *최종 스타일* 입니다.
상태에 지정된 스타일은 해당 엘리먼트가 이 상태로 전환된 시점부터 적용되기 시작하며, *다른 상태로 바뀌기 전까지* 계속 적용됩니다.

상태를 적용한 뒤에는 이 상태를 전환하는 *트랜지션*을 정의합니다.
각각의 트랜지션은 전환되는 상태와 애니메이션 타이밍으로 구성되며, 다음과 같이 정의합니다:

<code-example path="animations/src/app/hero-list-basic.component.ts" region="transitions" title="src/app/hero-list-basic.component.ts" linenums="false"></code-example>

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active.png" alt="In Angular animations you define states and transitions between states" width="400">
</figure>

<!--
If several transitions have the same timing configuration, you can combine
them into the same `transition` definition:
-->
그리고 여러 트랜지션에 같은 타이밍 효과를 지정하려면 다음과 같이 지정합니다:

<code-example path="animations/src/app/hero-list-combined-transitions.component.ts" region="transitions" title="src/app/hero-list-combined-transitions.component.ts" linenums="false"></code-example>

<!--
When both directions of a transition have the same timing, as in the previous
example, you can use the shorthand syntax `<=>`:
-->
이전 예제처럼 트랜지션이 양방향으로 적용된다면 간단하게 `<=>`라고 표현할 수도 있습니다:

<code-example path="animations/src/app/hero-list-twoway.component.ts" region="transitions" title="src/app/hero-list-twoway.component.ts" linenums="false"></code-example>

<!--
You can also apply a style during an animation but not keep it around
after the animation finishes. You can define such styles inline, in the `transition`. In this example,
the element receives one set of styles immediately and is then animated to the next.
When the transition finishes, none of these styles are kept because they're not
defined in a `state`.
-->
그리고 애니메이션 트랜지션이 진행되는 중에 적용될 스타일도 지정할 수 있습니다.
마찬가지로 이 스타일도 인라인으로 정의하거나 `transition`에 정의할 수 있으며, 이 스타일은 트랜지션이 시작될 때 바로 적용됩니다.
그리고 트랜지션이 종료되면 `state`에 지정되지 않은 스타일은 모두 해제됩니다.

<code-example path="animations/src/app/hero-list-inline-styles.component.ts" region="transitions" title="src/app/hero-list-inline-styles.component.ts" linenums="false"></code-example>

<!--
### The wildcard state `*`
-->
### 모든 상태 `*`

<!--
The `*` ("wildcard") state matches *any* animation state. This is useful for defining styles and
transitions that apply regardless of which state the animation is in. For example:
-->
모든 상태(wiltecard state)라고 하는 `*` 상태는 *모든* 애니메이션 상태와 매칭됩니다. 이 상태는 모든 애니메이션에 같은 스타일과 같은 트랜지션 효과를 정의할 때 사용합니다. 예를 들면:

<!--
* The `active => *` transition applies when the element's state changes from `active` to anything else.
* The `* => *` transition applies when *any* change between two states takes place.
-->
* `active => *` 트랜지션은 `active` 상태에서 다른 모든 상태로 전환될 때 적용됩니다.
* `* => *` 트랜지션은 *모든* 트랜지션에 적용됩니다.

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active_wildcards.png" alt="The wildcard state can be used to match many different transitions at once" width="400">
</figure>

<!--
### The `void` state
-->
### `void` 상태

<!--
The special state called `void` can apply to any animation. It applies
when the element is *not* attached to a view, perhaps because it has not yet been
added or because it has been removed. The `void` state is useful for defining enter and
leave animations.
-->
또 다른 특별 상태인 `void`를 활용할 수도 있습니다. 이 상태는 아직 뷰에 추가되지 않았거나, 뷰에서 사라진 직후의 엘리먼트, 즉 뷰에 *존재하지 않는* 엘리먼트에 적용되며, 이 상태를 활용하면 엘리먼트가 나타나거나 사라지는 애니메이션을 구현할 때 유용합니다.

<!--
For example the `* => void` transition applies when the element leaves the view,
regardless of what state it was in before it left.
-->
예를 들어 `* => void` 트랜지션은 이전의 상태와 관계없이 뷰에서 사라지는 엘리먼트에 모두 적용됩니다.

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_void_in.png" alt="The void state can be used for enter and leave transitions" width="400">
</figure>

<!--
The wildcard state `*` also matches `void`.
-->
모든 상태를 의미하는 `*`는 `void` 상태에도 적용됩니다.

<!--
## Example: Entering and leaving
-->
## 예제 : 나타날 때/사라질 때

<img src="generated/images/guide/animations/animation_enter_leave.gif" alt="Enter and leave animations" class="right" width="250">

<!--
Using the `void` and `*` states you can define transitions that animate the
entering and leaving of elements:

* Enter: `void => *`
* Leave: `* => void`

For example, in the `animations` array below there are two transitions that use
the `void => *` and `* => void` syntax to animate the element in and out of the view.
-->
`void` 상태와 `*` 상태를 사용하면 엘리먼트가 나타나거나 사라지는 애니메이션을 구현할 수 있습니다:

* 나타날 때 : `void => *`
* 사라질 때 : `* => void`

그래서 아래 코드는 두 상황에 대한 트랜지션 효과를 각각 정의하고 있습니다.

<code-example path="animations/src/app/hero-list-enter-leave.component.ts" region="animationdef" title="hero-list-enter-leave.component.ts (excerpt)" linenums="false"></code-example>

<!--
Note that in this case the styles are applied to the void state directly in the
transition definitions, and not in a separate `state(void)` definition. Thus, the transforms
are different on enter and leave: the element enters from the left
and leaves to the right.
-->
이 코드에서는 `void` 상태에 적용되는 스타일을 `state(void)`로 지정하지 않고 트랜지션 정의에 직접 지정했습니다.
그래서 엘리먼트가 나타날 때와 사라질 때 효과가 다르며, 엘리먼트가 나타날 때는 왼쪽부터 나타나고, 엘리먼트가 사라질 때는 오른쪽으로 사라집니다.

<div class="l-sub-section">

<!--
These two common animations have their own aliases:
-->
이 트랜지션 정의는 다음과 같이 정의할 수도 있습니다:

<code-example language="typescript">
  transition(':enter', [ ... ]); // void => *
  transition(':leave', [ ... ]); // * => void
</code-example>

</div>

<!--
## Example: Entering and leaving from different states
-->
## 예제 : 특정 상태로 전환될 때, 특정 상태에서 다른 상태로 전환될 때

<img src="generated/images/guide/animations/animation_enter_leave_states.gif" alt="Enter and leave animations combined with state animations" class="right" width="200">

<!--
You can also combine this animation with the earlier state transition animation by
using the hero state as the animation state. This lets you configure
different transitions for entering and leaving based on what the state of the hero
is:

* Inactive hero enter: `void => inactive`
* Active hero enter: `void => active`
* Inactive hero leave: `inactive => void`
* Active hero leave: `active => void`

This gives you fine-grained control over each transition:
-->
`void` 상태는 이전 예제에서 살펴본 다른 상태와도 함께 적용할 수 있습니다.
히어로 엘리먼트에 `active` 상태와 `inactive` 상태를 정의하면서, 이 엘리먼트가 나타나고 사라지는 애니메이션을 추가로 정의한다면 다음과 같이 정의할 수 있습니다:

* 비활성화 상태의 히어로가 나타날 때 : `void => inactive`
* 활성화 상태의 히어로가 나타날 때 : `void => active`
* 비활성화 상태의 히어로가 사라질 때 : `inactive => void`
* 활성화 상태의 히어로가 사라질 때 : `active => void`

이 트랜지션 관계를 그림으로 표현하면 다음과 같습니다:

<figure>
  <img src="generated/images/guide/animations/ng_animate_transitions_inactive_active_void.png" alt="This example transitions between active, inactive, and void states" width="400">
</figure>

<code-example path="animations/src/app/hero-list-enter-leave-states.component.ts" region="animationdef" title="hero-list-enter-leave.component.ts (excerpt)" linenums="false"></code-example>

## Animatable properties and units

Since Angular's animation support builds on top of Web Animations, you can animate any property
that the browser considers *animatable*. This includes positions, sizes, transforms, colors,
borders, and many others. The W3C maintains
[a list of animatable properties](https://www.w3.org/TR/css3-transitions/#animatable-properties)
on its [CSS Transitions page](https://www.w3.org/TR/css3-transitions).

For positional properties that have a numeric value, you can define a unit by providing
the value as a string with the appropriate suffix:

* `'50px'`
* `'3em'`
* `'100%'`

If you don't provide a unit when specifying dimension, Angular assumes the default of `px`:

* `50` is the same as saying `'50px'`

## Automatic property calculation

<img src="generated/images/guide/animations/animation_auto.gif" alt="Animation with automated height calculation" class="right" width="220">

Sometimes you don't know the value of a dimensional style property until runtime.
For example, elements often have widths and heights that
depend on their content and the screen size. These properties are often tricky
to animate with CSS.

In these cases, you can use a special `*` property value so that the value of the
property is computed at runtime and then plugged into the animation.

In this example, the leave animation takes whatever height the element has before it
leaves and animates from that height to zero:

<code-example path="animations/src/app/hero-list-auto.component.ts" region="animationdef" title="src/app/hero-list-auto.component.ts" linenums="false"></code-example>

## Animation timing

There are three timing properties you can tune for every animated transition:
the duration, the delay, and the easing function. They are all combined into
a single transition *timing string*.

### Duration

The duration controls how long the animation takes to run from start to finish.
You can define a duration in three ways:

* As a plain number, in milliseconds: `100`
* In a string, as milliseconds: `'100ms'`
* In a string, as seconds: `'0.1s'`

### Delay

The delay controls the length of time between the animation trigger and the beginning
of the transition. You can define one by adding it to the same string
following the duration. It also has the same format options as the duration:

* Wait for 100ms and then run for 200ms: `'0.2s 100ms'`

### Easing

The [easing function](http://easings.net/) controls how the animation accelerates
and decelerates during its runtime. For example, an `ease-in` function causes
the animation to begin relatively slowly but pick up speed as it progresses. You
can control the easing by adding it as a *third* value in the string after the duration
and the delay (or as the *second* value when there is no delay):

* Wait for 100ms and then run for 200ms, with easing: `'0.2s 100ms ease-out'`
* Run for 200ms, with easing: `'0.2s ease-in-out'`

<img src="generated/images/guide/animations/animation_timings.gif" alt="Animations with specific timings" class="right" width="220">

### Example

Here are a couple of custom timings in action. Both enter and leave last for
200 milliseconds, that is `0.2s`, but they have different easings. The leave begins after a
slight delay of 10 milliseconds as specified in `'0.2s 10 ease-out'`:

<code-example path="animations/src/app/hero-list-timings.component.ts" region="animationdef" title="hero-list-timings.component.ts (excerpt)" linenums="false"></code-example>

## Multi-step animations with keyframes

<img src="generated/images/guide/animations/animation_multistep.gif" alt="Animations with some bounce implemented with keyframes" class="right" width="220">

Animation *keyframes* go beyond a simple transition to a more intricate animation
that goes through one or more intermediate styles when transitioning between two sets of styles.

For each keyframe, you specify an *offset* that defines at which point
in the animation that keyframe applies. The offset is a number between zero,
which marks the beginning of the animation, and one, which marks the end.

This example adds some "bounce" to the enter and leave animations with
keyframes:

<code-example path="animations/src/app/hero-list-multistep.component.ts" region="animationdef" title="hero-list-multistep.component.ts (excerpt)" linenums="false"></code-example>

Note that the offsets are *not* defined in terms of absolute time. They are relative
measures from zero to one. The final timeline of the animation is based on the combination
of keyframe offsets, duration, delay, and easing.

Defining offsets for keyframes is optional. If you omit them, offsets with even
spacing are automatically assigned. For example, three keyframes without predefined
offsets receive offsets `0`, `0.5`, and `1`.

## Parallel animation groups

<img src="generated/images/guide/animations/animation_groups.gif" alt="Parallel animations with different timings, implemented with groups" class="right" width="220px">

You've seen how to animate multiple style properties at the same time:
just put all of them into the same `style()` definition.

But you may also want to configure different *timings* for animations that happen
in parallel. For example, you may want to animate two CSS properties but use a
different easing function for each one.

For this you can use animation *groups*. In this example, using groups both on
enter and leave allows for two different timing configurations. Both
are applied to the same element in parallel, but run independently of each other:

<code-example path="animations/src/app/hero-list-groups.component.ts" region="animationdef" title="hero-list-groups.component.ts (excerpt)" linenums="false"></code-example>

One group animates the element transform and width; the other group animates the opacity.

## Animation callbacks

A callback is fired when an animation is started and also when it is done.

In the keyframes example, you have a `trigger` called `@flyInOut`. You can hook
those callbacks like this:

<code-example path="animations/src/app/hero-list-multistep.component.ts" region="template" title="hero-list-multistep.component.ts (excerpt)" linenums="false"></code-example>

The callbacks receive an `AnimationEvent` that contains useful properties such as
`fromState`, `toState` and `totalTime`.

Those callbacks will fire whether or not an animation is picked up.
